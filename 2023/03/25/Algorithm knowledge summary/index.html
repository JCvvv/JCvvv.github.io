<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法设计与优化 | 锦尘</title><meta name="keywords" content="技术,sql"><meta name="author" content="锦尘"><meta name="copyright" content="锦尘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="算法设计与优化">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计与优化">
<meta property="og:url" content="https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/index.html">
<meta property="og:site_name" content="锦尘">
<meta property="og:description" content="算法设计与优化">
<meta property="og:locale">
<meta property="og:image" content="https://jcvvv.github.io/pic/cover/Algorithm%20knowledge%20summary.jpg">
<meta property="article:published_time" content="2023-03-24T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-26T12:23:06.420Z">
<meta property="article:author" content="锦尘">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jcvvv.github.io/pic/cover/Algorithm%20knowledge%20summary.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://jsdelivr.pai233.top/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://jsdelivr.pai233.top/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://jsdelivr.pai233.top/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://jsdelivr.pai233.top/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法设计与优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-26 20:23:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/pic/cover/Algorithm%20knowledge%20summary.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">锦尘</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法设计与优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-24T16:00:00.000Z" title="发表于 2023-03-25 00:00:00">2023-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-26T12:23:06.420Z" title="更新于 2023-11-26 20:23:06">2023-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10,633</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法设计与优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>1.注意事项：infinity表示无穷大，emptySet表示空集，NIL表示空，u.color表示结点s的颜色，u.d表示结点s相对于起点的距离，u.pi表示结点s的前驱结点</p>
<p>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(G, s)</span><br><span class="line"><span class="keyword">for</span> each vertex u <span class="keyword">in</span> (G.V-&#123;s&#125;)</span><br><span class="line">	u.color = WHITE</span><br><span class="line">	u.d = infinity</span><br><span class="line">	u.pi = NIL</span><br><span class="line">s.color = GRAY</span><br><span class="line">s.d = <span class="number">0</span></span><br><span class="line">s.pi = NIL</span><br><span class="line">Q = emptySet</span><br><span class="line">ENQUEUE(Q, s)</span><br><span class="line"><span class="keyword">while</span> Q != emptySet</span><br><span class="line">	u = DEQUEUE(Q)</span><br><span class="line">	<span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]</span><br><span class="line">		<span class="keyword">if</span> v.color == WHITE</span><br><span class="line">			v.color = GRAY</span><br><span class="line">			v.d = u.d + <span class="number">1</span></span><br><span class="line">			v.pi = u</span><br><span class="line">			ENQUEUE(Q, v)</span><br><span class="line">	u.color = BLACK </span><br></pre></td></tr></table></figure>

<p>3.时间复杂度</p>
<p>每个结点及其边都进行扫描且只扫描一次，因此为theta(|V|+|E|)<br>注：BFS算法生成的树是一棵最短路径树（shortest path tree）</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>1.注意事项：u.d表示结点u刚被发现的时间，u.f表示结点u处理完的时间</p>
<p>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DFS(G)</span><br><span class="line"><span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V</span><br><span class="line">	u.color = WHITE</span><br><span class="line">	u.pi = NIL</span><br><span class="line">time = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V</span><br><span class="line">	<span class="keyword">if</span> u.color == WHITE </span><br><span class="line">		DFS-VISITE(G, u)</span><br><span class="line"></span><br><span class="line">DFS-VISITE(G, u)</span><br><span class="line">time = time + <span class="number">1</span></span><br><span class="line">u.d = time</span><br><span class="line">u.color = GRAY</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G:Adj[u]</span><br><span class="line">	<span class="keyword">if</span> v.color == WHITE</span><br><span class="line">		v.pi = u</span><br><span class="line">		DFS-VISITE(G, v)</span><br><span class="line">u.color = BLACK</span><br><span class="line">time = time + <span class="number">1</span></span><br><span class="line">u.f = time</span><br></pre></td></tr></table></figure>



<p>3.时间复杂度</p>
<p>DFS中的初始化theta(|V|)和对每个白色结点进行算法theta(|V|)，DFS-VISITE中遍历结点的相邻的边为theta(|adj[u]|)，所有的边总和为theta(|E|)，因此总时间复杂度为theta(|V|+|E|)</p>
<p>4.定理、引理和推论证明</p>
<p>（1）定理：括号化定理：在对有向或无向图G &#x3D; (V, E)进行的任意深度优先搜索中，对于任意两个结点u和v来说，下面三种情况只有一种成立<br>区间[u.d, u.f]和区间[v.d, v.f]完全分离，在深度优先森林中，结点u不是结点v的后代，结点v也不是结点u的后代<br>区间[u.d, u.f]完全包含在区间[v.d, v.f]内，在深度优先森林中，结点u是结点v的后代<br>区间[v.d, v.f]完全包含在区间[u.d, u.f]内，在深度优先森林中，结点v是结点u的后代<br>证明：根据祖孙和后代之间的关系以及时间来分析</p>
<p>（2）推论：后代区间的嵌套：在有向或无向图G的深度优先森林中，结点v是结点u的真后代当且仅当u.d &lt; v.d &lt; v.f &lt; u.f<br>证明：由上述括号化定理易证</p>
<p>（3）定理：白色路径定理：在有向或无向图G &#x3D; (V, E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径<br>证明：<br>&#x3D;&gt;：如果v是u的后代，且从u到v只有1个点，即u等于v，那么显然成立。如果v是u的真后代，那么根据后代区间的嵌套推论有u.d &lt; v.d，即在发现u时，v还没发现，此时v是白色的，而且v可以是任意后代，因此从u到v路径上的每个后代都是白色的，即存在一条白色路径。<br>&lt;&#x3D;：存在从u到v是一条白色路径，此时是在u刚被发现时的情况。那么，u.d &lt; v.d。而此时u.f或在u.d和v.d之间或在v.d之后，u和v之间存在路径说明u和v存在祖先后代的关系，根据括号化定理，v.f在v.d和u.f之间，此时满足后代区间嵌套的推论，即v是u的后代。</p>
<p>（4）定理：在对无向图G进行深度优先搜索时，每条边要么是树边，要么是后向边<br>证明：假定任意一条边(u, v)，有u.d &lt; v.d，那么如果在扫描u的邻接结点时发现了v即(u, v)，那么(u, v)是树边，如果在扫描v的邻接结点时发现的u即(u, v)，那么(u, v)是后向边。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>1.注意事项：算法对象有向无环图</p>
<p>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">（<span class="number">1</span>）call DFS(G) to compute finishing times f[v] <span class="keyword">for</span> each vertex v</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">as</span> each vertex <span class="keyword">is</span> finished, insert it onto the front of a linked <span class="built_in">list</span></span><br><span class="line">（<span class="number">3</span>）<span class="keyword">return</span> the linked <span class="built_in">list</span> of vertices</span><br></pre></td></tr></table></figure>

<p>3.时间复杂度<br>调用DFS为theta(|V|+|E|)，生成链表为theta(|V|)，返回链表为theta(1)<br>总共为theta(|V|+|E|)</p>
<p>4.定理、引理和推论证明</p>
<p>（1）引理：一个有向图G&#x3D;(V, E)是无环的当且仅当对其进行的深度优先搜索不产生后向边<br>证明：<br>&#x3D;&gt;：假设有向图无环并产生了一条后向边(u, v)，那么v是u的祖先，此时v是灰色的，根据白色路径定理，当发现v时，有一条从v到u的白色路径，因此出现了一个环路。矛盾，假设不成立。<br>&lt;&#x3D;：假设不含后向边的图G含有环路，环路中有两个点u和v，假设v是第一个发现的，即v.d&lt;u.d根据白色路径定理，在发现v时，环路中的点都是白色的，因此从v到u存在一条白色路径，因此u是v的后代。因为u和v在环路中，因此有一条从u指向v的边，且是后代指向祖先的后向边。矛盾，假设不成立。</p>
<p>（2）定理：拓扑排序算法TOPOLOGICAL-SORT生成的是有向无环图的拓扑排序<br>证明：（根据拓扑排序的定义，我们只要证明图中的任意一条边(u, v)，有u.f &gt; v.f，图中只有四种边，并且图是无环的，没有后向边，因此只需注意判断其他三种边即可）如果(u, v)是前向边，即u是v的祖先，那么u.f &gt; v.f一定成立；如果(u, v)是树边，u是v的父亲节点，因此必有u.f &gt; v.f；如果(u, v)是横向边，即u和v没有祖先和后代之间的关系，并且v一定已经先处理完，再发现u，因此，u.f &gt; v.f。综上，得证。</p>
<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>1.注意事项：算法对象有向图；算法中的第二次DFS时，转置图按结束时间从大到小排序；证明中的第二个引理是根据原图而不是转置图；G.T表示图G的转置</p>
<p>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STRONGLY-CONNECTED-COMPONENTS(G) </span><br><span class="line">（<span class="number">1</span>）call DFS(G) to compute finishing times u.f <span class="keyword">for</span> each vertex u</span><br><span class="line">（<span class="number">2</span>）compute G.T</span><br><span class="line">（<span class="number">3</span>）call DFS(G.T), but <span class="keyword">in</span> the main loop of DFS, consider the vertices <span class="keyword">in</span> order of decreasing u.f (<span class="keyword">as</span> computed <span class="keyword">in</span> line <span class="number">1</span>)</span><br><span class="line">（<span class="number">4</span>）output the vertices of each tree <span class="keyword">in</span> the depth-first forest formed <span class="keyword">in</span> line <span class="number">3</span> <span class="keyword">as</span> a seperate strongly connected component</span><br></pre></td></tr></table></figure>


<p>3.时间复杂度<br>两次DFS为theta(|V|+|E|)，求图的转置为theta(|V|+|E|)<br>总共为theta(|V|+|E|)</p>
<p>4.定理、引理和推论证明</p>
<p>（1）引理：设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量，设结点u, v 属于C，结点u’, v’ 属于C’，假定图G包含一条从结点u到结点u’的路径u<del>u’。 那么图G不可能包含一条从结点v’到结点v的路径v’</del>v。<br>证明：如果图G包含一条从结点v’到结点v的路径v’<del>v， 则G也将包含路径u</del> u’~ v’和v’~ v~u。因此，u和v’可以互相到达，从而与C和C’是不同的强连通分量的假设矛盾</p>
<p>（2）引理：设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量。假如存在一条(u, v) 属于E，这里u属于C，v属于C’，则f(C ) &gt; f(C’)。（d(U) &#x3D; min{u.d}、f(U) &#x3D; max{u.f} 其中U是V的子集，u属于U）<br>证明：</p>
<p>分为两种情况考虑：a. d(C ) &lt; d(C’) b. d(C ) &gt; d(C’)</p>
<p>a.第一种情况：设x是C中第一个被发现的结点，那么d(C ) &#x3D; x.d，C中其余结点在刚发现x时都是白色的，C’中的所有结点此时也是白色的，那么x就能从通过结点u和边(u, v)到达C’中。根据强连通分量的性质和白色路径定理，C和C’中的所有结点都是x的后代，那么f(C ) &#x3D; x.f，因此自然有f(C ) &gt; f(C’)</p>
<p>b. 第二种情况：设y是C’中第一个被发现的结点，那么f(C’) &#x3D; y.f，d(C’) &#x3D; y.d，由于d(C ) &gt; d(C’)并且C’中的结点无法到达C中，因此C’中的结点一定先被处理，因此d(C ) &gt; f(C’)，推出f(C ) &gt; f(C’)</p>
<p>（3）推论：设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量，假如存在一条边(u, v) 属于E.T，这里u属于C，v属于C’，则f(C ) &lt; f(C’)<br>证明：G.T中有一条从u到v的边，那么在G中这条边就是从v到u的，v属C’而u属于C，根据之前的引理，那么f(C ) &lt; f(C’)</p>
<p>（4）定理：算法STRONGLY-CONNECTED COMPONENTS能够正确计算出有向图G的强连通分量<br>证明：（现在考虑的图是G.T，即第二次的深度优先搜索树和强连通分支对应）采用归纳假设，即第二次深度优先搜索时产生的前k棵树都是强连通分量。当k&#x3D;0时，此时没有树显然成立。假定前k棵树都是强连通分量。现在考虑第(k+1)棵树，假设结点u是该树中第一个被发现的结点，且u在强连通分量C中，那么在u刚被发现时，C中所有结点都是白色的，根据白色路径定理，C中的所有结点都是结点u在搜索树中的后代，因此可以排除强连通分量的结点不在树中的情况。根据推论（设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量，假如存在一条边(u, v) 属于E.T，这里u属于C，v属于C’，则f(C ) &lt; f(C’)）我们能知道，如果存在一条从C到达其他未发现的强连通分量C’的路径，那么f(C ) &lt; f(C’)，而在第二次深度优先搜索中，我们访问结点的次序是按照完成时间的非递增顺序，有f(C ) &gt; f(C’)，也就是说不可能存在从C到C’的路径，但可能存在从C到已发现的强连通分量的路径并且由于已发现的强连通分量中的结点都是黑色的，不可能对其进行访问，因此可以排除树中的结点不在强连通分量中的情况。综上，以u为结点的树恰好构成强连通分量C，证明结束。</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列是一种使用堆的数据结构，支持高效地插入元素和找到最大元素值。<br>堆序：对于每个结点的值v，其结点的父结点的值w，有key(w) &gt; key(v)<br>leftChild(i) &#x3D; 2i，rightChild(i) &#x3D; 2i + 1，parent(i) &#x3D; floor(i&#x2F;2)<br>Sift-up：将一个元素向上浮动 O(log n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: An array H[<span class="number">1.</span>..n] <span class="keyword">and</span> an index i between <span class="number">1</span> <span class="keyword">and</span> n.</span><br><span class="line">Output: H[i] <span class="keyword">is</span> moved up, <span class="keyword">if</span> necessary, so that it <span class="keyword">is</span> <span class="keyword">not</span> larger than its parent.</span><br><span class="line">done &lt;- false</span><br><span class="line"><span class="keyword">if</span> z = <span class="number">1</span> then exit &#123;node i <span class="keyword">is</span> the root&#125;</span><br><span class="line">repeat</span><br><span class="line">	<span class="keyword">if</span> key(H[i]) &gt; key(H[lower(i/<span class="number">2</span>)]) then interchange H[i] <span class="keyword">and</span> H[lower(i/<span class="number">2</span>)]</span><br><span class="line">	<span class="keyword">else</span> done &lt;- true</span><br><span class="line">	i &lt;- lower(i/<span class="number">2</span>)</span><br><span class="line">until i = <span class="number">1</span> <span class="keyword">or</span> done</span><br></pre></td></tr></table></figure>


<p>Sift-down：将一个元素向下浮动 O(log n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: An array H[<span class="number">1.</span>..n] <span class="keyword">and</span> an index i between <span class="number">1</span> <span class="keyword">and</span> n.</span><br><span class="line">Output: H[i] <span class="keyword">is</span> percolated down, <span class="keyword">if</span> necessary, so that it <span class="keyword">is</span> <span class="keyword">not</span> smaller than its children</span><br><span class="line">done &lt;- false</span><br><span class="line"><span class="keyword">if</span> 2i &gt; n then exit &#123;node <span class="keyword">is</span> a leaf&#125;</span><br><span class="line">repeat</span><br><span class="line">	i &lt;- 2i</span><br><span class="line">	<span class="keyword">if</span> i+<span class="number">1</span> &lt;= n <span class="keyword">and</span> key(H[i+<span class="number">1</span>]) &gt; key(H[i]) then i &lt;- i + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> key(H[lower(i/<span class="number">2</span>)]) &lt; key(H[i]) then interchange H[i] <span class="keyword">and</span> H[lower(i/<span class="number">2</span>)]</span><br><span class="line">	<span class="keyword">else</span> done &lt;- true</span><br><span class="line">	end <span class="keyword">if</span></span><br><span class="line">until 2i &gt; n <span class="keyword">or</span> done</span><br></pre></td></tr></table></figure>

<p>MakeHeap(n)：建立一个含有n个元素的堆O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: An array A[<span class="number">1.</span>..n] of n elements</span><br><span class="line">Output: A[<span class="number">1.</span>..n] <span class="keyword">is</span> transformed into a heap</span><br><span class="line"><span class="keyword">for</span> i &lt;- lower(n/<span class="number">2</span>) downto <span class="number">1</span></span><br><span class="line">	Sift-down(A, i)</span><br><span class="line">end <span class="keyword">for</span></span><br></pre></td></tr></table></figure>


<p>Insert(H, x)：向堆H中插入值为x的元素O(log n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A heap H[<span class="number">1.</span>..n] <span class="keyword">and</span> a heap element x.</span><br><span class="line">Output: A new heap H[<span class="number">1.</span>..n+<span class="number">1</span>] <span class="keyword">with</span> x being one of its elements.</span><br><span class="line">n &lt;- n+<span class="number">1</span> &#123;increase the size of H&#125;</span><br><span class="line">H[n] &lt;- x</span><br><span class="line">Sift-up(H, n)</span><br></pre></td></tr></table></figure>


<p>FindMax(H)：堆顶元素即为最大值O(1)</p>
<p>Delete(H, i)：删除指定位置的元素O(log n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: A nonempty heap H[<span class="number">1.</span>..] <span class="keyword">and</span> an index i between <span class="number">1</span> <span class="keyword">and</span> n.</span><br><span class="line">Output: A new heap H[<span class="number">1.</span>..n-<span class="number">1</span>] after H[i] <span class="keyword">is</span> removed.</span><br><span class="line">x &lt;- H[i]; y &lt;- H[n]</span><br><span class="line">n &lt;- n-<span class="number">1</span> &#123;decrease the size of H&#125;</span><br><span class="line"><span class="keyword">if</span> i = n + <span class="number">1</span> then exit &#123;done&#125;</span><br><span class="line">H[i] &lt;- y</span><br><span class="line"><span class="keyword">if</span> (key(y) &gt;= key(x)) then Sift-up(H, i)</span><br><span class="line"><span class="keyword">else</span> Sift-down(H, i)</span><br><span class="line">end <span class="keyword">if</span></span><br></pre></td></tr></table></figure>


<p>ExtractMax(H)：删除最大元素O(log n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A heap H[<span class="number">1.</span>..n]</span><br><span class="line">Output: An element x of maximum key <span class="keyword">is</span> returned <span class="keyword">and</span> deleted <span class="keyword">from</span> the heap</span><br><span class="line">x &lt;- H[<span class="number">1</span>]</span><br><span class="line">Delete(H, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>



<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>一个算法是贪婪的，如果它建立了通过每一个小步骤的解决方案，在每一小个步骤选择一个决定，以优化一些潜在的标准。</p>
<p>贪心算法通常被设计来解决最优化问题，即最小化或最大化一个量。它通常由一个迭代过程组成，该过程试图找到一个局部最优解。在某些实例中，这些局部最优解转变为全局最优解。在其他实例中，它们不能给出最优解。贪心算法在很少计算的基础上做出选择，并且不关心未来。因此，它逐步构建了一个解。每一步都基于局部优化增加了部分解的规模。所做出的选择，是在保持可行性的同时产生最大的即时收益。由于每一步都由基于少量信息的少量工作组成，因此产生的算法通常是有效的。贪心算法设计中的困难部分是证明该算法确实解决了它被要求解决的问题。</p>
<h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><p>注意事项：单源最短路径问题（Single-source shortest paths problem）<br>先看一道题</p>
<p>一个加权有向图G，采用下面哪个选项，在改动之后能保证最短路径不变。</p>
<ul>
<li>A.每条边都加上17</li>
<li>B.每条边都乘以17</li>
<li>C.A和B</li>
<li>D.既不是A也不是B</li>
</ul>
<p>答案是B，考虑一种情况最短路径是2条边权值分别为2和3，还有一条边是6，那么最短路径为2+3&#x3D;5，如果是A那么(2+17)+(3+17) &gt; 6+17，最短路径改变，而B选项是同时扩大，因此最短路径不变。也就是如果最短路径边数很多，那么选A，则会处于明显劣势。<br>“What’s the shortest way to travel from Rotterdam to Groningen? It is the algorithm for the shortest path, which I designed in about 20 minutes. One morning I was shopping in Amsterdam with my young fiancée, and tired, we sat down on the café terrace to drink a cup of coffee and I was just thinking about whether I could do this, and I then designed the algorithm for the shortest path. ”— Edsger Dijsktra</p>
<p>在介绍迪杰斯特拉算法之前，先说一下需要用到的函数“松弛操作”中包括2个函数INITIALIZE-SINGLE-SOURCE(G, s)和RELAX(u, v, w)在第377页,松弛是唯一导致最短路径和前驱结点发生变化的操作</p>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">S = emptySet</span><br><span class="line">Q = G.V</span><br><span class="line"><span class="keyword">while</span> Q != emptySet</span><br><span class="line">	u = EXTRACT-MIN(Q)</span><br><span class="line">	S = S union &#123;u&#125;</span><br><span class="line">	<span class="keyword">for</span> each vertex <span class="keyword">in</span> G.Adj[u]</span><br><span class="line">		RELAX(u, v, w)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V-&#123;s&#125;</span><br><span class="line">	alpha[v] = infinity // s到v的距离</span><br><span class="line">	pi[v] = NIL // v的前驱结点</span><br><span class="line">alpha[s] = <span class="number">0</span></span><br><span class="line">Create an empty priority queue PQ // 创建优先队列PQ</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V</span><br><span class="line">	INSERT(PQ, v, alpha[v]) // 关键值为alpha[v]</span><br><span class="line"><span class="keyword">while</span> PQ != empty</span><br><span class="line">	u = EXTRACT-MIN(PQ) // 从优先队列中找到最小的，把u作为出发点</span><br><span class="line">	<span class="keyword">for</span> each edge e = (u,v) leaving u</span><br><span class="line">		<span class="keyword">if</span> alpha[v] &gt; alpah[u] + le // le是边的长度</span><br><span class="line">			alpha[v] = alpha[v] + le</span><br><span class="line">			pi[v] = u</span><br><span class="line">			Reset-Key(PQ, v, alpha[v]) // 修改以调整优先队列</span><br></pre></td></tr></table></figure>

<p>时间复杂度</p>
<p>迪杰斯特拉算法的时间复杂度依赖于最小优先队列的实现。我们这里采用的是最小二叉堆。初始化即构建最小二叉堆O(n)，将每个结点从Q中删除是O(log n)那n个点是O(nlog n)，for each共执行m次，由于是二叉堆修改的时间复杂度为O(log n)，那么总共就是O(nlog n + mlog n)，由于连通图中 m &gt;&#x3D; n-1，因此总共就是O(mlog n)</p>
<p>定理、引理和推论证明</p>
<p>（1）（Dijsktra算法的正确性）Dijsktra算法运行在带权重的有向图G &#x3D; (V, E)时，如果所有权重为非负值，则在所有算法终止时，对于所有结点u属于V，我们有u.d &#x3D; 最短距离(s, u)。</p>
<p>证明：采用数学归纳法。当|S| &#x3D; 1时，因为S &#x3D; {s}并且d[s] &#x3D; 0，成立。假设当|S| &gt;&#x3D; 1时也成立。令v为下一个将要被加入到S中的结点，令u是v的在S中的前驱结点，alpha(v) &#x3D; d[u] + w(u, v)。我们只需证明没有任何一条路径的长度小于alpha(v)。考虑另外一条从s到v的路径P，令x是P中最后一个在S中的结点，令y的前驱结点为x。由于算法中是将alpha（估计值）最小的结点加入S中，因此一定有alpha(v) &lt;&#x3D; alpha(y)，那么P &#x3D; alpha(y) + P(y, v) &gt;&#x3D; alpha(y) &gt;&#x3D; alpha(v)，则d[v] &#x3D; alpha(v)一定是最小值。综上，算法是正确的。</p>
<p>注：<br>迪杰斯特拉算法生成的是最短路径树（shortest path tree）<br>为什么迪杰斯特拉算法要求权值非负呢？<br>先举一个反例，如果存在两组边分别为10和-8，3和3，那么算法就会优先选择3和3的一组边，而实际最短的是10和-8。如果权值为负，那么在上面的证明中就无法推出alpha(y) + P(y, v) &gt;&#x3D; alpha(y)，因为P(y, v)可能为负。综上，权值必须为非负的，才能保证正确性。<br>为什么迪杰斯特拉算法是一种贪心算法？<br>算法在运行时，每次都将估计值最小的结点加入集合S中。</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>注意事项：Kruscal算法和Prim算法都是贪心算法，Kruscal算法每次加入到A中的安全边永远是连接A和A之外某个结点的边中权重最小的边，Prim算法每次加入的边都必须是使树的总权重增加量最小的边。</p>
<p>伪代码：</p>
<p>（1）Kruscal算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MST-KRUSCAL(G, w)</span><br><span class="line">A = emptySet</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V</span><br><span class="line">	MAKE-SET(v)</span><br><span class="line">sort the edges of G.E into nondecreasing order by weight w</span><br><span class="line"><span class="keyword">for</span> each edge(u, v) <span class="keyword">in</span> G.E, taken <span class="keyword">in</span> nondecreasing order by weight</span><br><span class="line">	<span class="keyword">if</span> FIND-SET(u) != FIND-SET(v)</span><br><span class="line">		A = A union &#123;(u, v)&#125;</span><br><span class="line">		UNION(u, v)</span><br><span class="line"><span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>


<p>（2）Prim算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MST-PRIM(G, w, r)</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V-&#123;s&#125;</span><br><span class="line">	alpha[v] = infinity </span><br><span class="line">	pi[v] = NIL // v的前驱结点</span><br><span class="line">alpha[s] = <span class="number">0</span></span><br><span class="line">Create an empty priority queue PQ // 创建优先队列PQ</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V</span><br><span class="line">	INSERT(PQ, v, alpha[v]) // 关键值为alpha[v]</span><br><span class="line"><span class="keyword">while</span> PQ != empty</span><br><span class="line">	u = EXTRACT-MIN(PQ) // 从优先队列中找到最小的</span><br><span class="line">	<span class="keyword">for</span> each edge e = (u,v) 且v在PQ中</span><br><span class="line">		<span class="keyword">if</span> w(u, v) &lt; alpha[v] </span><br><span class="line">			alpha[v] = w(u, v)</span><br><span class="line">			pi[v] = u</span><br><span class="line">			Reset-Key(PQ, v, alpha[v]) // 修改以调整优先队列</span><br></pre></td></tr></table></figure>

<p>3.时间复杂度</p>
<p>Kruscal算法和Prim算法都为O(mlog n)</p>
<p>4.定理、引理和推论证明</p>
<p>（1）定理：设G &#x3D; (V, E)是一个在边E上定义了实数值权重函数w的连通无向图。设集合A为E的一个子集，且A包括在图G的某棵最小生成树中，设(S, V-S)是图G中尊重集合A的任意一个切割，又设(u, v)是横跨切割(S, V-S)的一条轻量级边。那么边(u, v)对于集合A是安全的。</p>
<p>证明：设T是一棵包含A的最小生成树，如果T包含(u, v)，那么该边对A集合一定是安全的。如果T不包含(u, v)，那么由于切割(S, V-S)尊重A，而A又是T的一部分，因此一定存在从S到V-S横跨切割的一条边(x, y)，该边不在A中且是T的一部分。设u在S中，v在V-S中，那么一定存在一条从u到v的经过(x, y)的简单路径。如果形成了一棵包含(u, v)的最小生成树T’，那么(u, v)对于A一定是安全的。如果直接将(u, v)加入其中，那么会与之前从u到v经过(x, y)的简单路径形成环，因此我们必须将(x, y)删除，T会形成两个连通分量，而加入(u, v)则可以将这两个连通分量连起来形成一棵新的生成树T’，我们要证明T’是最小生成树。因为T是一棵最小生成树，因此T中边的权重之和w(T) &lt;&#x3D; w(T’)，由(u, v)是轻量边，因此有边的权重w(u, v) &lt;&#x3D; w(x, y)，则有w(T’) &lt;&#x3D; w(T)，推出w(T’) &#x3D; w(T)，即T’也是一棵最小生成树。A是T的一部分，(x, y)不是T的一部分，因此A是T’ 的一部分，所以A并上(u, v)也是T’ 的一部分，而T’ 是一棵最小生成树，那么(u, v)对于A来说一定是安全的。</p>
<p>（2）推论：设G &#x3D; (V, E)是一个连通无向图，并有定义在边集合E上的实数值权重函数w。设集合A为E的一个子集，且该子集包括在G的某棵最小生成树里，并设C &#x3D; (Vc, Ec)为森林Ga &#x3D; (V, A)中的一个连通分量（树）。如果边(u, v)是连接C和Ga中某个其他连通分量的一条轻量级边，则边(u, v)对于集合A是安全的。</p>
<p>证明：切割(Vc, V - Vc)尊重集合A，边(u, v)是横跨该切割的一条轻量级边，因此，边(u, v)对于集合A是安全的。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集表示一组不连通集合的一种数据结构</p>
<p>并查集需要支持三种操作：</p>
<p>（1）MAKE-SET(x)：创造一个仅包含x的新连通分支（集合）</p>
<p>（2）FIND(x)：返回包含元素x的集合的代表元（就像是国家有主席、总统一样，代表元是该集合的代表）</p>
<p>（3）UNION(x, y)：将x和y所在的集合取并集，并用新的集合代替他们</p>
<p>令m &#x3D; 上述三种操作的总的调用次数、n &#x3D; 元素的数量</p>
<p>四种实现方式：</p>
<ul>
<li>naïve linking：自然连接</li>
<li>link-by-rank：根据秩数连接</li>
<li>path compression：路径压缩</li>
<li>link-by-rank with path compression：带有路径压缩的根据秩数的连接</li>
</ul>
<p>naïve linking方式<br>将第一个结点所在树的根节点连接到第二个结点所在树的根节点上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MAKE-SET(x)</span><br><span class="line">parent[x] = x</span><br><span class="line"></span><br><span class="line">FIND(x)</span><br><span class="line"><span class="keyword">while</span> (x != parent[x])</span><br><span class="line">x = parent[x]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">UNION(x, y) </span><br><span class="line">r = FIND(x)</span><br><span class="line">z = FIND(y)</span><br><span class="line">parent[r] = z</span><br></pre></td></tr></table></figure>


<p>定理：在最坏的情况下（形成了一个链表），一次find操作花费theta(n)时间，n是元素的数量</p>
<p>link-by-rank方式</p>
<p>每个结点保持一个整数——秩，初始时，所有集合的秩为0，在这里秩数等于树的高度。秩小的集合连接到秩大的集合中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MAKE-SET(x)</span><br><span class="line">parent[x] = x</span><br><span class="line">rank[x] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">FIND(x)</span><br><span class="line"><span class="keyword">while</span> (x != parent[x])</span><br><span class="line">x = parent[x]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">UNION(x, y)</span><br><span class="line">r = FIND(x)</span><br><span class="line">s = FIND(y)</span><br><span class="line"><span class="keyword">if</span> (r == s)</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank[r] &lt; rank[s])</span><br><span class="line">	parent[r] = s</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank[r] &gt; rank[r])</span><br><span class="line">	parent[s] = r</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	parent[r] = s</span><br><span class="line">	rank[s] = rank[s] + <span class="number">1</span>  // 秩相同时，将其中一个的秩+<span class="number">1</span>，将另一个连过来</span><br></pre></td></tr></table></figure>


<p>该方法的6个性质：</p>
<p>（1）如果x不是根结点，那么rank[x]不会再发生改变。<br>证明：算法中只改变根结点的秩，而非根结点不会再变为根结点。</p>
<p>（2）如果x不是根结点，那么rank[x] &lt; rank[parent[x]]。<br>证明：一个秩为k+1的根结点，只会通过两个秩为k的根结点合并产生。</p>
<p>（3）如果parent[x]改变，那么rank[parent[x]]严格增加。<br>证明：如果parent[x]改变，那么x一定是根结点，那么改变前有parent[x] &#x3D;&#x3D; x，在x改变，即被连接到新的结点r时，有rank[parent[x]] &#x3D; rank[r] &gt; rank[x]。</p>
<p>（4）任何一个秩为k的结点，在以它为根结点的树中，至少含有2^k个结点。<br>证明：当k&#x3D;0时，成立。做归纳假设，秩为k-1的节点，以它为根的树至少包含2^ (k-1）个结点。证明对秩为k的根结点依然成立。只有两个秩都为k-1的树合并，才能出现秩为k的树，根据归纳假设，这两课树至少含有2^ (k-1)个节点，合并后，至少含有2^k个结点，所以归纳假设成立。</p>
<p>（5）一个结点的秩的最大值为lower(log n)。<br>证明：有性质（4）很容易推出</p>
<p>（6）秩为k的结点数量最多为n&#x2F;2^k。<br>证明：由性质（4）任何一个秩为k的结点，在其子树中至少含有2^k个结点。秩为k的不同结点不可能含有相同的后代。</p>
<p>定理：在最坏的情况下，UNION和FIND操作，需要花费O(log n)的时间。</p>
<p>证明：这两个操作以树的高度为界，而在性质（5）中，树的高度最高为lower(log n)。</p>
<p>path compression</p>
<p>路径压缩是针对FIND操作的重新组织</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FIND(x)</span><br><span class="line"><span class="keyword">if</span> (x != parent[x])</span><br><span class="line">parent[x] = FIND(parent[x])</span><br><span class="line"><span class="keyword">return</span> parent[x]</span><br></pre></td></tr></table></figure>

<p>通过递归调用，将从x到根结点的路径上的所有结点的父结点都改为根结点。<br>路径压缩改变了树的结构。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划历史：Bellman 动态规划的先驱<br>斐波那契数列（Fibonacci Sequence）的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 自顶向下</span><br><span class="line">TOP-DOWN(n)</span><br><span class="line">Initialize M[<span class="number">0.</span>..n] <span class="keyword">with</span> -<span class="number">1</span> // -<span class="number">1</span>: unfilled</span><br><span class="line">M[<span class="number">0</span>] &lt;- <span class="number">0</span>; M[<span class="number">1</span>] &lt;- <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fibonacci(n)</span><br><span class="line"></span><br><span class="line">fibonacci(j)</span><br><span class="line"><span class="keyword">if</span> (M[j] == -<span class="number">1</span>)</span><br><span class="line">	M[j] &lt;- fibonacci(j-<span class="number">1</span>) + fibonacci(j-<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> M[j]</span><br><span class="line"></span><br><span class="line">// 自底向上</span><br><span class="line">BOTTOM-UP(n)</span><br><span class="line">Initialize M[<span class="number">0.</span>..n] <span class="keyword">with</span> -<span class="number">1</span></span><br><span class="line">M[<span class="number">0</span>] &lt;- <span class="number">0</span>; M[<span class="number">1</span>] &lt;- <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span> to n</span><br><span class="line">	M[i] &lt;- M[i-<span class="number">1</span>] + M[i-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>有向无环图中的单源最短路径问题（第24章 第2节）<br>有向无环图（directed acyclic graph DAG）<br>书中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DAG-SHORTEST-PATH(G, w, s)</span><br><span class="line">topologically sort the vertices of G</span><br><span class="line">INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line"><span class="keyword">for</span> each vertex u, taken <span class="keyword">in</span> topologically <span class="built_in">sorted</span> order</span><br><span class="line">	<span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]</span><br><span class="line">		RELAX(u, v, w)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DAG-SHORTEST-PATH(G, w, s)</span><br><span class="line">topologically sort the vertices of G</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.V</span><br><span class="line">	v.d = infinity</span><br><span class="line">	v.pi = NIL</span><br><span class="line">s.d = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each vertex u, taken <span class="keyword">in</span> topologically <span class="built_in">sorted</span> order</span><br><span class="line">	<span class="keyword">for</span> each vertex v <span class="keyword">in</span> G.Adj[u]</span><br><span class="line">		<span class="keyword">if</span> v.d &gt; u.d + w(u, v)</span><br><span class="line">			v.d = u.d + w(u, v)</span><br><span class="line">			v.pi = u</span><br></pre></td></tr></table></figure>

<p>算法时间复杂度：拓扑排序theta(V+E)，初始化theta(V)，每条边进行了一次松弛为theta(E)，因此总运行时间为theta(V+E)</p>
<p>动态规划可以被使用，如果满足下面的条件</p>
<p>1.由多项式数量的子问题组成</p>
<p>2.原问题的解决可以简单地由子问题计算而来</p>
<p>3.从“最小”到“最大”有一个子问题的简单的顺序</p>
<p>子问题之间有清晰的相互依赖关系，这是动态规划算法的核心。如斐波那契数列、有向无环图中的单源最短路径问题</p>
<p>动态规划技术通常用于解决最优化问题</p>
<p>0-1背包问题（Knapsack problem）</p>
<p>定义：OPT(i, w) &#x3D; 在重量限制w的情况下，从1到i个物品放入背包中的最大价值。</p>
<p>目标：OPT(n, W)</p>
<p>Bellman equation</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KNAPSACK(n, W, w1, w2, ..., wn, v1, v2, ..., vn)</span><br><span class="line"><span class="keyword">for</span> w=<span class="number">0</span> to W</span><br><span class="line">	M[<span class="number">0</span>, w] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</span><br><span class="line">	<span class="keyword">for</span> w=<span class="number">0</span> to W</span><br><span class="line">		<span class="keyword">if</span> (wi &gt; w)</span><br><span class="line">			M[i, w] = M[i-<span class="number">1</span>, w]</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			M[i, w] = <span class="built_in">max</span>&#123;M[i-<span class="number">1</span>, w], vi+M[i-<span class="number">1</span>, w-wi]&#125;</span><br><span class="line"><span class="keyword">return</span> M[n, W]</span><br></pre></td></tr></table></figure>

<p>算法时间复杂度：O(nW)，但这个不是多项式时间算法。（这个解释如果大家想去了解，可以去网上搜索相关资料）</p>
<p>从(n, W)的方格向上移动，如果两个方格(i, w)与(i-1, w)的值相同，说明物体i没有放入背包；如果不相同说明物体i放入了背包中，根据Bellman equation，移动到上一行(i-1, w-wi)，按照这个规则继续下去。同则向上，不同则移动。</p>
<p>在本例中，右下角为(5, 11)值为40，向上(4, 11)仍为40，说明物体5没有放入背包中，再往上(3, 11)为25，说明物体4放入了背包中，那么11kg-6kg&#x3D;5kg，所以上一个位置移动到(3, 5)方格值为18，向上(2, 5)值为7，说明物体3放入了背包中，5kg-5kg&#x3D;0kg，因此上一个位置移动到(2, 0)方格，接下来一直到(0, 0)值没有变化，即没有新的物体放入背包中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 输入部分</span></span><br><span class="line">	<span class="type">int</span> W; <span class="comment">// 背包容量</span></span><br><span class="line">	<span class="type">int</span> n; <span class="comment">// 物体数量</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入背包容量（正整数）：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; W;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入物体数量（正整数）：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> w[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 每个物体的重量</span></span><br><span class="line">	<span class="type">int</span> v[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 每个物体的价值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入物体重量和价值按照&quot;</span>重量 价值<span class="string">&quot;输入：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解部分</span></span><br><span class="line"><span class="type">int</span> table[n+<span class="number">1</span>][W+<span class="number">1</span>]; <span class="comment">// 动态规划表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= W; i++)</span><br><span class="line">	table[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= W; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (w[i] &gt; j)</span><br><span class="line">			table[i][j] = table[i<span class="number">-1</span>][j];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			table[i][j] = <span class="built_in">max</span>(table[i<span class="number">-1</span>][j], v[i] + table[i<span class="number">-1</span>][j-w[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> things[n+<span class="number">1</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">// 装入背包中的物品</span></span><br><span class="line"><span class="type">int</span> k = W;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (table[i][k] &gt; table[i<span class="number">-1</span>][k])</span><br><span class="line">	&#123;</span><br><span class="line">		things[i] = <span class="literal">true</span>;</span><br><span class="line">		k -= w[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出部分</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动态规划表为：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= W; j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>, table[i][j]);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;应该装入物品：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (things[i])</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最优解的值为：&quot;</span> &lt;&lt; table[n][W] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &gt;= j ? i : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>带有负环的最短路径问题</p>
<p>负环（negative cycle）是一个有向环，环中边的权重之和为负值。</p>
<p>正环（positive cycle）是一个有向环，环中边的权重之和为正值。（不可能出现）</p>
<p>0环是一个有向环，环中边的权重之和为0。（可以出现，但没必要）</p>
<p>引理1：如果存在从s -&gt; v的路径包含负环，那么不存在从s -&gt; v的最短路径</p>
<p>证明：如果存在这样的负环，那么可以无限的经过负环，降低路径上的权重和。</p>
<p>引理2：如果图G不存在负环，那么存在从s -&gt; v的一条简单最短路径。（最短路径不含环）</p>
<p>为了解决一般的单源最短路径问题，我们将这个问题分成两个，一个是不含负环的单源最短路径问题，一个是负环的识别问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Def. OPT(i, v) = length of shortest s -&gt; v path that uses at most i edges.</span><br><span class="line">Goal. OPT(n-<span class="number">1</span>, v) <span class="keyword">for</span> each v.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SHORTEST-PATHS(V, E, l, s)</span><br><span class="line">foreach node v <span class="keyword">in</span> V:</span><br><span class="line">	M[<span class="number">0</span>, v] &lt;- infinity</span><br><span class="line">M[<span class="number">0</span>, s] &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n-<span class="number">1</span></span><br><span class="line">	foreach node v <span class="keyword">in</span> V:</span><br><span class="line">		M[i, v] &lt;- M[i-<span class="number">1</span>, v]</span><br><span class="line">		foreach edge(u, v) <span class="keyword">in</span> E</span><br><span class="line">			M[i, v] &lt;- <span class="built_in">min</span>&#123;M[i, v], M[i-<span class="number">1</span>, u] + luv&#125;</span><br></pre></td></tr></table></figure>


<p>空间复杂度：O(n^2) 一个二维数组</p>
<p>时间复杂度：O(nm)</p>
<p>存储图的数据结构可以采用以入边为依据的邻接链表</p>
<p>作业2：对下图进行填表（s为出发点）</p>
<p>结果：</p>
<p>如何通过表得到顶点s到各个顶点的最短路径长度？表中最后一行就是从s到各个顶点的最短路径长度。<br>如何通过表得到顶点s到各个顶点的最短路径？其实我认为通过上面的动态规划表也是可以的，和之前的方式一样，如果发生变化就通过计算得到之前的点……。老师说可以改变算法结构，增加一个二维数组pn-1，用来记录前驱顶点，通过这个新的二维数组的最后一行就可以得到路径，但我通过检验其实一维数组p[v]也是完全可以的。但还是通过维护一个记录前驱的一维数组进行回溯方便。</p>
<p>我们可以通过维护两个一维数组，而不是维护一个二维数组<br>d[v] &#x3D; length of a shortest s-&gt;v path that we have found so far.<br>predecessor[v] &#x3D; preceding node on the above s-&gt;v path.</p>
<p>引理3：对每一个顶点，d[v]是单调非递增的。</p>
<p>引理4：在第i次迭代后，d[v]是当前从s-&gt;v用最多i条边的最短路径长度。</p>
<p>证明：当i &#x3D; 0时成立。假设第i次后，成立。那么在第i+1次后，令p是另一个从s-&gt;v的含有最多i+1条边的路径，令u是v的前驱顶点，那么从s-&gt;u最多包含i条边，设从s-&gt;u的任意路径为p’，那么根据归纳假设有d[u] &lt;&#x3D; l(p’)，因此有d[v] &#x3D; d[u] + luv &lt;&#x3D; l(p’ ) + luv &#x3D; l(p )，所以假设成立。（这个证明很重要）</p>
<p>推论：如果最短路径含有k条边，那么算法可以在最多k次迭代后找到最短路径。</p>
<p>定理2：假设没有负环，Bellman-Ford计算从s-&gt;v的最短路径，时间复杂度为O(mn)，空间复杂度为theta(n)</p>
<p>证明：引理2+引理4</p>
<p>负环检测问题（Detecting negative cycles）</p>
<p>先用Bellman-Ford算法迭代n-1次，接着再迭代1次，如果最短路径长度继续减小，说明一定含有负环。</p>
<p>引理5：对于每个结点v，如果有OPT(n, v) &#x3D; OPT(n-1, v)，那么没有负环。</p>
<p>证明：（OPT(n+1, v)的推导中，OPT(n-1, u) + luv &#x3D; OPT(n, v)，因此得到最后的结果。这是老师给的证明方法，更为直观一些，但用归纳法证明更好。）</p>
<p>引理6：如果对某些结点有OPT(n, v) &lt; OPT(n-1, v)，那么从s-&gt;v的长度为n最短路径一定含有环W，且是负环。</p>
<p>证明：如果OPT(n, v) &lt; OPT(n-1, v)，任何s-&gt;v的最短路p，最多含有n条边，实际上更准确的是含有n条边，否则OPT(n, v) &#x3D; OPT(n-1, v)。由鸽巢原理，路径p一定包含重复的结点x，令W为路径p中的环，如果W不是负环，那么删除W，则s-&gt;v最多有n-1条边并且有OPT(n, v) &#x3D; OPT(n-1, v)。此时产生矛盾，因此W是负环。<br>引理6的逆否命题：引理6’：如果不含负环，那么对于每个结点有OPT(n, v) &#x3D; OPT(n-1, v)。</p>
<p>定理4：如果对于每个结点v有OPT(n, v) &#x3D; OPT(n-1, v)，当且仅当不含负环。</p>
<p>证明：引理5 + 引理6’</p>
<p>定理5：能够在theta(mn)的时间内，找到一个负环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BELLMAN-FORD(V, E, l, s)</span><br><span class="line">foreach node v <span class="keyword">in</span> V:</span><br><span class="line">	d[v] &lt;- infinity</span><br><span class="line">	predecessor[v] &lt;- null</span><br><span class="line">d[s] &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n-<span class="number">1</span>:</span><br><span class="line">	foreach node v <span class="keyword">in</span> V:</span><br><span class="line">		foreach edge(u, v) <span class="keyword">in</span> E:</span><br><span class="line">			<span class="keyword">if</span> (d[v] &gt; d[u] + luv)</span><br><span class="line">				d[v] &lt;- d[u] + luv</span><br><span class="line">				predecessor[v] &lt;- u</span><br><span class="line">foreach edge(u, v) <span class="keyword">in</span> E:</span><br><span class="line">	<span class="keyword">if</span> (d[v] &gt; d[u] + luv)</span><br><span class="line">		<span class="keyword">return</span> true // 含有负环</span><br><span class="line"><span class="keyword">return</span> false // 不含有负环</span><br></pre></td></tr></table></figure>



<h3 id="所有结点对之间的最短距离"><a href="#所有结点对之间的最短距离" class="headerlink" title="所有结点对之间的最短距离"></a>所有结点对之间的最短距离</h3><p>给一个nxn的权值矩阵W，表示有向图G &#x3D; (W, E)边的权值。输出一个距离矩阵D &#x3D; (dij)，表示顶点i和顶点j之间的距离。</p>
<p>定义：Lij(m) &#x3D; i -&gt; j 的路径且最多含有m条边</p>
<p>目标：Lij(n-1) 每一对顶点i和j（不能含有负环）</p>
<p>lij(m)表示，从 i 到 j 最多含有m条边的最短路长度</p>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ALL-PAIRS-SHORTEST-PATHS(W)</span><br><span class="line">n = W.rows</span><br><span class="line">L(<span class="number">1</span>) = W </span><br><span class="line"><span class="keyword">for</span> m = <span class="number">2</span> to n-<span class="number">1</span></span><br><span class="line">	let L(m) be a new n x n matrix</span><br><span class="line">	L(m) = EXTEND-SHORTEST-PATHS(L(m-<span class="number">1</span>), W) </span><br><span class="line"><span class="keyword">return</span> L(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">EXTEND-SHORTEST-PATHS(L, W)</span><br><span class="line">n = L.rows</span><br><span class="line">let L’ = (Lij’) be a new n x n matrix</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n </span><br><span class="line">	<span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">		Lij’ = infinity</span><br><span class="line">		<span class="keyword">for</span> k = <span class="number">1</span> to n</span><br><span class="line">			Lij’ = <span class="built_in">min</span>(Lij’, Lik + wkj)</span><br><span class="line"><span class="keyword">return</span> L’</span><br></pre></td></tr></table></figure>


<p>时间复杂度 O(n^4)</p>
<p>Lij(m) &#x3D; min{Lik(m-1) + wkj | 1 &lt;&#x3D; k &lt;&#x3D; n}，这个我感觉很漂亮，很像矩阵相乘</p>
<p>Lij(4) &#x3D; min{Lik(2) + Lkj(2) | 1 &lt;&#x3D; k &lt;&#x3D; n}<br>当最后一次进入主过程的循环时，2m &gt; n-1，由第十部分动态规划中的Bellman-Ford算法，我们已经知道，此时的Lij(2m)已经收敛等于Lij(n-1)<br>（不能含有负环）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ALL-PAIRS-SHORTEST-PATHS(W)</span><br><span class="line">n = W.rows</span><br><span class="line">L(<span class="number">1</span>) = W </span><br><span class="line">m = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> m &lt; n - <span class="number">1</span></span><br><span class="line">	let L(2m) be a new n x n matrix</span><br><span class="line">	L(2m) = EXTEND-SHORTEST-PATHS(L(m), L(m)) </span><br><span class="line">	m = 2m</span><br><span class="line"><span class="keyword">return</span> L(m)</span><br></pre></td></tr></table></figure>


<p>时间复杂度 O(n^3 logn)</p>
<p>Floyd-Warshall Algorithm</p>
<p>定义：dij(k) &#x3D; i -&gt; j的最短路径长度，其中间结点的下标取自{1, 2, …, k}中（下标）</p>
<p>目标：对于每一对结点i和j计算dij(n)</p>
<p>第k个结点不在路径中，第k个结点在路径中。只有这两种可能。（不能含有负环）</p>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FLOYD-WARSHALL ALGORITHM</span><br><span class="line">n = W.rows</span><br><span class="line">D(<span class="number">0</span>) = W</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> to n</span><br><span class="line">	let D(k) = (dij(k)) be a new n x n matrix</span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">		<span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">			dij(k) = <span class="built_in">min</span>(dij(k-<span class="number">1</span>), dik(k-<span class="number">1</span>) + dkj(k-<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> D(n)</span><br></pre></td></tr></table></figure>


<p>时间复杂度 O(n^3)</p>
<p>可以含有负环的算法：Johnson’s ALgorithm</p>
<h3 id="NP完全性"><a href="#NP完全性" class="headerlink" title="NP完全性"></a>NP完全性</h3><p>问题有两种描述方式，优化模式（Optimization Problem）和判别模式（Decision Problem）</p>
<p>归约：一个步骤f，可以将问题A的任何一个实例都转换成问题B的实例并且要满足下面的两个要求。</p>
<p>Transformation：这个转换过程必须在多项式时间内完成。</p>
<p>Equivalence：一个实例或一个项，必须同时为YES或NO。（注意下面的定义，“问题A可以在多项式时间内被归约为问题B”，小p指的是多项式时间）</p>
<p>定理：如果问题B可以在多项式时间内被解决，那么A也可以在多项式时间内被解决。</p>
<p>证明：</p>
<p>（1）给定一个问题A的一个实例alpha，使用多项式时间归约为beita &#x3D; f(alpha)</p>
<p>（2）运用B的多项式时间算法，解决实例beita &#x3D; f(alpha)</p>
<p>（3）使用beita的答案作为alpha的答案</p>
<p>定理：相反地，如果A不存在多项式时间算法，那么B也不存在多项式时间算法（该定理是之前定理的逆否命题）</p>
<p>Vertex Cover顶点覆盖问题</p>
<p>输入：一个图G &#x3D; (V, E)和一个整数k</p>
<p>输出：是否存在一个顶点集合S属于V，|S| &#x3D; k，使得每条边至少和这k个顶点中的一个相关联，能找到为YES，找不到为NO</p>
<p>Set Cover集合覆盖问题</p>
<p>输入：一个含有n个元素的集合U &#x3D; {e1, e2, …, en}，给一系列的m个子集S &#x3D; {S1, S2, …, Sm}，和一个整数k</p>
<p>输出：是否存在一个集合C属于S，使得C中各集合的元素的并集为U并且|C| &lt;&#x3D; k，存在为YES，不存在为NO</p>
<p>定理：顶点覆盖问题可以在多项式时间内归约为集合覆盖问题</p>
<p>证明：给一个顶点集合实例G &#x3D; (V, E)和k，我们构造一个集合覆盖实例(U, S, k)，使得S中的k个集合能够覆盖U，当且仅当G有一个大小为k的顶点集合覆盖。</p>
<p>构造（Construction）：</p>
<ul>
<li>令U &#x3D; E</li>
<li>对于V中的每一个v，构造一个集合Sv &#x3D; {e属于E，e关联于v}</li>
</ul>
<p>（简单点说，就是E中的每一条边就是U中的每一个元素，V中的每个顶点就是S中的每个集合，V中顶点关联的边就是S中集合的元素）</p>
<p>断言（Claim）：G &#x3D; (V, E)有一个大小为k的顶点覆盖当且仅当(U, S)有一个大小为k的集合覆盖</p>
<p>证明：</p>
<p>&#x3D;&gt;   令X是V的子集，是一个在G中大小为k的顶点覆盖<br>       令Y &#x3D; {Sv : v属于X}是一个大小为k的集合覆盖</p>
<p>&lt;&#x3D;   令Y属于S，是一个大小为k的集合覆盖<br>       令X &#x3D; {v : Sv属于Y}是一个在G中大小为k的顶点覆盖</p>
<p>Construction + Claim &#x3D;&gt; 顶点覆盖可以在多项式时间内归约为集合覆盖<br>（也就是说顶点覆盖比集合覆盖在计算上更容易，因此用式子表示式小于等于号）</p>
<p>3SAT问题（3-SATISFIABILITY Problem）</p>
<p>3SAT Problem是SAT问题的特殊情况，即每一个子句中恰好包含了3个文字</p>
<p>独立集问题（Independent Set Problem）</p>
<p>输入：给定一个图G &#x3D; (V, E)，和一个整数k<br>输出：是否存在一组顶点的集合S属于V，|S| &#x3D; k，使得没有在S中没有两个顶点由一条边相连（即集合S中的k个顶点，两两不相邻）</p>
<p>定理：3SAT问题可以在多项式时间内归约为独立集问题</p>
<p>证明：给定一个3SAT问题的实例，我们构造一个独立集问题(G, k)，其有一个大小为k的独立集，当且仅当3SAT问题的实例是可满足的<br>构造（Construction）：</p>
<ul>
<li>每个子句中的1个文字对应1个顶点</li>
<li>每个子句中的3个文字所对应的3个顶点，两两相邻，构成一个三角</li>
<li>不同子句间互为相反的文字连接起来</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jcvvv.github.io">锦尘</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/">https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jcvvv.github.io" target="_blank">锦尘</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/sql/">sql</a></div><div class="post_share"><div class="social-share" data-image="/pic/cover/Algorithm%20knowledge%20summary.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://jsdelivr.pai233.top/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://jsdelivr.pai233.top/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/01/Operating%20system%20experiments/"><img class="prev-cover" src="/pic/cover/Operating%20system%20experiments.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统实验</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/14/Operating%20system%20summary/"><img class="next-cover" src="/pic/cover/Operating%20system%20summary.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统知识点汇总</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/14/Operating%20system%20summary/" title="操作系统知识点汇总"><img class="cover" src="/pic/cover/Operating%20system%20summary.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">操作系统知识点汇总</div></div></a></div><div><a href="/2023/10/20/Data%20Mining/" title="数据挖掘实验报告"><img class="cover" src="/pic/cover/Data%20Mining.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-20</div><div class="title">数据挖掘实验报告</div></div></a></div><div><a href="/2023/10/30/SMS/" title="SMS短信嗅探实验报告"><img class="cover" src="/pic/cover/SMS.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-30</div><div class="title">SMS短信嗅探实验报告</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">锦尘</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JCvvv" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/475586532?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="mailto:1747624698@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.</span> <span class="toc-text">广度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">2.</span> <span class="toc-text">深度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">强连通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">迪杰斯特拉算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">9.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">10.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E5%AF%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-number">11.</span> <span class="toc-text">所有结点对之间的最短距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NP%E5%AE%8C%E5%85%A8%E6%80%A7"><span class="toc-number">12.</span> <span class="toc-text">NP完全性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/25/Data%20visualization%20course%20design/" title="数据可视化知识点">数据可视化知识点</a><time datetime="2024-03-25T15:56:41.462Z" title="发表于 2024-03-25 23:56:41">2024-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/NoSqlExperiment/" title="NoSql实验报告">NoSql实验报告</a><time datetime="2023-11-19T16:00:00.000Z" title="发表于 2023-11-20 00:00:00">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/Internship%20report/" title="认知实习汇总">认知实习汇总</a><time datetime="2023-10-31T16:00:00.000Z" title="发表于 2023-11-01 00:00:00">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/31/Software/" title="软件工程作业合集">软件工程作业合集</a><time datetime="2023-10-30T16:00:00.000Z" title="发表于 2023-10-31 00:00:00">2023-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/30/SMS/" title="SMS短信嗅探实验报告">SMS短信嗅探实验报告</a><time datetime="2023-10-29T16:00:00.000Z" title="发表于 2023-10-30 00:00:00">2023-10-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/foot.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 锦尘</div><div class="footer_custom_text">欢迎你，不知道从哪来的朋友</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://jsdelivr.pai233.top/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://jsdelivr.pai233.top/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://jsdelivr.pai233.top/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>