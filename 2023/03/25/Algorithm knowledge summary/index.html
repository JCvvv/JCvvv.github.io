<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法设计与优化 | 锦尘</title><meta name="keywords" content="技术,sql"><meta name="author" content="锦尘"><meta name="copyright" content="锦尘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="算法设计与优化">
<meta property="og:type" content="article">
<meta property="og:title" content="算法设计与优化">
<meta property="og:url" content="https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/index.html">
<meta property="og:site_name" content="锦尘">
<meta property="og:description" content="算法设计与优化">
<meta property="og:locale">
<meta property="og:image" content="https://jcvvv.github.io/pic/cover/18.jpg">
<meta property="article:published_time" content="2023-03-24T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-31T02:38:22.228Z">
<meta property="article:author" content="锦尘">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jcvvv.github.io/pic/cover/18.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法设计与优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-31 10:38:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/pic/cover/18.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">锦尘</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法设计与优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-24T16:00:00.000Z" title="发表于 2023-03-25 00:00:00">2023-03-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-31T02:38:22.228Z" title="更新于 2023-07-31 10:38:22">2023-07-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13,863</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法设计与优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一．广度优先搜索（Breadth-first-Search）"><a href="#一．广度优先搜索（Breadth-first-Search）" class="headerlink" title="一．广度优先搜索（Breadth-first Search）"></a>一．广度优先搜索（Breadth-first Search）</h3><p>1.注意事项：infinity表示无穷大，emptySet表示空集，NIL表示空，u.color表示结点s的颜色，u.d表示结点s相对于起点的距离，u.pi表示结点s的前驱结点<br>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(G, s)</span><br><span class="line"><span class="keyword">for</span> each vertex u <span class="keyword">in</span> (G.V-&#123;s&#125;)</span><br><span class="line">	u.color = WHITE</span><br><span class="line">	u.d = infinity</span><br><span class="line">	u.pi = NIL</span><br><span class="line">s.color = GRAY</span><br><span class="line">s.d = <span class="number">0</span></span><br><span class="line">s.pi = NIL</span><br><span class="line">Q = emptySet</span><br><span class="line">ENQUEUE(Q, s)</span><br><span class="line"><span class="keyword">while</span> Q != emptySet</span><br><span class="line">	u = DEQUEUE(Q)</span><br><span class="line">	<span class="keyword">for</span> each v <span class="keyword">in</span> G.Adj[u]</span><br><span class="line">		<span class="keyword">if</span> v.color == WHITE</span><br><span class="line">			v.color = GRAY</span><br><span class="line">			v.d = u.d + <span class="number">1</span></span><br><span class="line">			v.pi = u</span><br><span class="line">			ENQUEUE(Q, v)</span><br><span class="line">	u.color = BLACK </span><br></pre></td></tr></table></figure>

<p>3.时间复杂度<br>每个结点及其边都进行扫描且只扫描一次，因此为theta(|V|+|E|)<br>注：BFS算法生成的树是一棵最短路径树（shortest path tree）</p>
<h3 id="二．深度优先搜索（Depth-first-Search）"><a href="#二．深度优先搜索（Depth-first-Search）" class="headerlink" title="二．深度优先搜索（Depth-first Search）"></a>二．深度优先搜索（Depth-first Search）</h3><p>1.注意事项：u.d表示结点u刚被发现的时间，u.f表示结点u处理完的时间<br>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DFS(G)</span><br><span class="line"><span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V</span><br><span class="line">	u.color = WHITE</span><br><span class="line">	u.pi = NIL</span><br><span class="line">time = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each vertex u <span class="keyword">in</span> G.V</span><br><span class="line">	<span class="keyword">if</span> u.color == WHITE </span><br><span class="line">		DFS-VISITE(G, u)</span><br><span class="line"></span><br><span class="line">DFS-VISITE(G, u)</span><br><span class="line">time = time + <span class="number">1</span></span><br><span class="line">u.d = time</span><br><span class="line">u.color = GRAY</span><br><span class="line"><span class="keyword">for</span> each vertex v <span class="keyword">in</span> G:Adj[u]</span><br><span class="line">	<span class="keyword">if</span> v.color == WHITE</span><br><span class="line">		v.pi = u</span><br><span class="line">		DFS-VISITE(G, v)</span><br><span class="line">u.color = BLACK</span><br><span class="line">time = time + <span class="number">1</span></span><br><span class="line">u.f = time</span><br></pre></td></tr></table></figure>




<p>3.时间复杂度<br>DFS中的初始化theta(|V|)和对每个白色结点进行算法theta(|V|)，DFS-VISITE中遍历结点的相邻的边为theta(|adj[u]|)，所有的边总和为theta(|E|)，因此总时间复杂度为theta(|V|+|E|)<br>4.定理、引理和推论证明<br>（1）定理：括号化定理：在对有向或无向图G &#x3D; (V, E)进行的任意深度优先搜索中，对于任意两个结点u和v来说，下面三种情况只有一种成立<br>区间[u.d, u.f]和区间[v.d, v.f]完全分离，在深度优先森林中，结点u不是结点v的后代，结点v也不是结点u的后代<br>区间[u.d, u.f]完全包含在区间[v.d, v.f]内，在深度优先森林中，结点u是结点v的后代<br>区间[v.d, v.f]完全包含在区间[u.d, u.f]内，在深度优先森林中，结点v是结点u的后代<br>证明：根据祖孙和后代之间的关系以及时间来分析<br>（2）推论：后代区间的嵌套：在有向或无向图G的深度优先森林中，结点v是结点u的真后代当且仅当u.d &lt; v.d &lt; v.f &lt; u.f<br>证明：由上述括号化定理易证<br>（3）定理：白色路径定理：在有向或无向图G &#x3D; (V, E)的深度优先森林中，结点v是结点u的后代当且仅当在发现结点u的时间u.d，存在一条从结点u到结点v的全部由白色结点所构成的路径<br>证明：<br>&#x3D;&gt;：如果v是u的后代，且从u到v只有1个点，即u等于v，那么显然成立。如果v是u的真后代，那么根据后代区间的嵌套推论有u.d &lt; v.d，即在发现u时，v还没发现，此时v是白色的，而且v可以是任意后代，因此从u到v路径上的每个后代都是白色的，即存在一条白色路径。<br>&lt;&#x3D;：存在从u到v是一条白色路径，此时是在u刚被发现时的情况。那么，u.d &lt; v.d。而此时u.f或在u.d和v.d之间或在v.d之后，u和v之间存在路径说明u和v存在祖先后代的关系，根据括号化定理，v.f在v.d和u.f之间，此时满足后代区间嵌套的推论，即v是u的后代。<br>（4）定理：在对无向图G进行深度优先搜索时，每条边要么是树边，要么是后向边<br>证明：假定任意一条边(u, v)，有u.d &lt; v.d，那么如果在扫描u的邻接结点时发现了v即(u, v)，那么(u, v)是树边，如果在扫描v的邻接结点时发现的u即(u, v)，那么(u, v)是后向边。</p>
<h3 id="三．拓扑排序（Topological-Sort）"><a href="#三．拓扑排序（Topological-Sort）" class="headerlink" title="三．拓扑排序（Topological Sort）"></a>三．拓扑排序（Topological Sort）</h3><p>1.注意事项：算法对象有向无环图<br>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">（<span class="number">1</span>）call DFS(G) to compute finishing times f[v] <span class="keyword">for</span> each vertex v</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">as</span> each vertex <span class="keyword">is</span> finished, insert it onto the front of a linked <span class="built_in">list</span></span><br><span class="line">（<span class="number">3</span>）<span class="keyword">return</span> the linked <span class="built_in">list</span> of vertices</span><br></pre></td></tr></table></figure>


<p>3.时间复杂度<br>调用DFS为theta(|V|+|E|)，生成链表为theta(|V|)，返回链表为theta(1)<br>总共为theta(|V|+|E|)<br>4.定理、引理和推论证明<br>（1）引理：一个有向图G&#x3D;(V, E)是无环的当且仅当对其进行的深度优先搜索不产生后向边<br>证明：<br>&#x3D;&gt;：假设有向图无环并产生了一条后向边(u, v)，那么v是u的祖先，此时v是灰色的，根据白色路径定理，当发现v时，有一条从v到u的白色路径，因此出现了一个环路。矛盾，假设不成立。<br>&lt;&#x3D;：假设不含后向边的图G含有环路，环路中有两个点u和v，假设v是第一个发现的，即v.d&lt;u.d根据白色路径定理，在发现v时，环路中的点都是白色的，因此从v到u存在一条白色路径，因此u是v的后代。因为u和v在环路中，因此有一条从u指向v的边，且是后代指向祖先的后向边。矛盾，假设不成立。<br>（2）定理：拓扑排序算法TOPOLOGICAL-SORT生成的是有向无环图的拓扑排序<br>证明：（根据拓扑排序的定义，我们只要证明图中的任意一条边(u, v)，有u.f &gt; v.f，图中只有四种边，并且图是无环的，没有后向边，因此只需注意判断其他三种边即可）如果(u, v)是前向边，即u是v的祖先，那么u.f &gt; v.f一定成立；如果(u, v)是树边，u是v的父亲节点，因此必有u.f &gt; v.f；如果(u, v)是横向边，即u和v没有祖先和后代之间的关系，并且v一定已经先处理完，再发现u，因此，u.f &gt; v.f。综上，得证。</p>
<h3 id="四．强连通分量（Strongly-Connected-Components）"><a href="#四．强连通分量（Strongly-Connected-Components）" class="headerlink" title="四．强连通分量（Strongly Connected Components）"></a>四．强连通分量（Strongly Connected Components）</h3><p>1.注意事项：算法对象有向图；算法中的第二次DFS时，转置图按结束时间从大到小排序；证明中的第二个引理是根据原图而不是转置图；G.T表示图G的转置</p>
<p>2.伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STRONGLY-CONNECTED-COMPONENTS(G) </span><br><span class="line">（<span class="number">1</span>）call DFS(G) to compute finishing times u.f <span class="keyword">for</span> each vertex u</span><br><span class="line">（<span class="number">2</span>）compute G.T</span><br><span class="line">（<span class="number">3</span>）call DFS(G.T), but <span class="keyword">in</span> the main loop of DFS, consider the vertices <span class="keyword">in</span> order of decreasing u.f (<span class="keyword">as</span> computed <span class="keyword">in</span> line <span class="number">1</span>)</span><br><span class="line">（<span class="number">4</span>）output the vertices of each tree <span class="keyword">in</span> the depth-first forest formed <span class="keyword">in</span> line <span class="number">3</span> <span class="keyword">as</span> a seperate strongly connected component</span><br></pre></td></tr></table></figure>


<p>3.时间复杂度<br>两次DFS为theta(|V|+|E|)，求图的转置为theta(|V|+|E|)<br>总共为theta(|V|+|E|)</p>
<p>4.定理、引理和推论证明<br>（1）引理：设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量，设结点u, v 属于C，结点u’, v’ 属于C’，假定图G包含一条从结点u到结点u’的路径u<del>u’。 那么图G不可能包含一条从结点v’到结点v的路径v’</del>v。<br>证明：如果图G包含一条从结点v’到结点v的路径v’<del>v， 则G也将包含路径u</del> u’~ v’和v’~ v~u。因此，u和v’可以互相到达，从而与C和C’是不同的强连通分量的假设矛盾<br>（2）引理：设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量。假如存在一条(u, v) 属于E，这里u属于C，v属于C’，则f(C ) &gt; f(C’)。（d(U) &#x3D; min{u.d}、f(U) &#x3D; max{u.f} 其中U是V的子集，u属于U）<br>证明：<br>分为两种情况考虑：a. d(C ) &lt; d(C’) b. d(C ) &gt; d(C’)<br>a.第一种情况：设x是C中第一个被发现的结点，那么d(C ) &#x3D; x.d，C中其余结点在刚发现x时都是白色的，C’中的所有结点此时也是白色的，那么x就能从通过结点u和边(u, v)到达C’中。根据强连通分量的性质和白色路径定理，C和C’中的所有结点都是x的后代，那么f(C ) &#x3D; x.f，因此自然有f(C ) &gt; f(C’)<br>b. 第二种情况：设y是C’中第一个被发现的结点，那么f(C’) &#x3D; y.f，d(C’) &#x3D; y.d，由于d(C ) &gt; d(C’)并且C’中的结点无法到达C中，因此C’中的结点一定先被处理，因此d(C ) &gt; f(C’)，推出f(C ) &gt; f(C’)<br>（3）推论：设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量，假如存在一条边(u, v) 属于E.T，这里u属于C，v属于C’，则f(C ) &lt; f(C’)<br>证明：G.T中有一条从u到v的边，那么在G中这条边就是从v到u的，v属C’而u属于C，根据之前的引理，那么f(C ) &lt; f(C’)<br>（4）定理：算法STRONGLY-CONNECTED COMPONENTS能够正确计算出有向图G的强连通分量<br>证明：（现在考虑的图是G.T，即第二次的深度优先搜索树和强连通分支对应）采用归纳假设，即第二次深度优先搜索时产生的前k棵树都是强连通分量。当k&#x3D;0时，此时没有树显然成立。假定前k棵树都是强连通分量。现在考虑第(k+1)棵树，假设结点u是该树中第一个被发现的结点，且u在强连通分量C中，那么在u刚被发现时，C中所有结点都是白色的，根据白色路径定理，C中的所有结点都是结点u在搜索树中的后代，因此可以排除强连通分量的结点不在树中的情况。根据推论（设C和C’为有向图G &#x3D; (V, E)的两个不同的强连通分量，假如存在一条边(u, v) 属于E.T，这里u属于C，v属于C’，则f(C ) &lt; f(C’)）我们能知道，如果存在一条从C到达其他未发现的强连通分量C’的路径，那么f(C ) &lt; f(C’)，而在第二次深度优先搜索中，我们访问结点的次序是按照完成时间的非递增顺序，有f(C ) &gt; f(C’)，也就是说不可能存在从C到C’的路径，但可能存在从C到已发现的强连通分量的路径并且由于已发现的强连通分量中的结点都是黑色的，不可能对其进行访问，因此可以排除树中的结点不在强连通分量中的情况。综上，以u为结点的树恰好构成强连通分量C，证明结束。</p>
<h3 id="五．优先级队列（Priority-Queue）"><a href="#五．优先级队列（Priority-Queue）" class="headerlink" title="五．优先级队列（Priority Queue）"></a>五．优先级队列（Priority Queue）</h3><p>优先级队列是一种使用堆的数据结构，支持高效地插入元素和找到最大元素值。<br>堆序：对于每个结点的值v，其结点的父结点的值w，有key(w) &gt; key(v)<br>leftChild(i) &#x3D; 2i，rightChild(i) &#x3D; 2i + 1，parent(i) &#x3D; floor(i&#x2F;2)<br>Sift-up：将一个元素向上浮动 O(log n)</p>
<p>Input: An array H[1…n] and an index i between 1 and n. <br>Output: H[i] is moved up, if necessary, so that it is not larger than its parent. <br>1.done &lt;- false <br>2.if z &#x3D; 1 then exit {node i is the root} <br>3.repeat <br>    if key(H[i]) &gt; key(H[lower(i&#x2F;2)]) then interchange H[i] and H[lower(i&#x2F;2)] <br>    else done &lt;- true <br>    i &lt;- lower(i&#x2F;2) <br>4.until i &#x3D; 1 or done<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>Sift-down：将一个元素向下浮动 O(log n)</p>
<p>Input: An array H[1…n] and an index i between 1 and n.<br>Output: H[i] is percolated down, if necessary, so that it is not smaller than its children<br>1.done &lt;- false<br>2.if 2i &gt; n then exit {node is a leaf}<br>3.repeat<br>    i &lt;- 2i<br>    if i+1 &lt;&#x3D; n and key(H[i+1]) &gt; key(H[i]) then i &lt;- i+1<br>    if key(H[lower(i&#x2F;2)]) &lt; key(H[i]) then interchange H[i] and H[lower(i&#x2F;2)]<br>    else done &lt;- true<br>    end if<br>4.until 2i &gt; n or done<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>MakeHeap(n)：建立一个含有n个元素的堆O(n)</p>
<p>Input: An array A[1…n] of n elements<br>Output: A[1…n] is transformed into a heap<br>1.for i &lt;- lower(n&#x2F;2) downto 1<br>    Sift-down(A, i)<br>2.end for<br>1<br>2<br>3<br>4<br>5<br>Insert(H, x)：向堆H中插入值为x的元素O(log n)</p>
<p>Input: A heap H[1…n] and a heap element x.<br>Output: A new heap H[1…n+1] with x being one of its elements.<br>1.n &lt;- n+1 {increase the size of H}<br>2.H[n] &lt;- x<br>3.Sift-up(H, n)<br>1<br>2<br>3<br>4<br>5<br>FindMax(H)：堆顶元素即为最大值O(1)</p>
<p>Delete(H, i)：删除指定位置的元素O(log n)</p>
<p>Input: A nonempty heap H[1…] and an index i between 1 and n.<br>Output: A new heap H[1…n-1] after H[i] is removed.<br>1.x &lt;- H[i]; y &lt;- H[n]<br>2.n &lt;- n-1 {decrease the size of H}<br>3.if i &#x3D; n + 1 then exit {done}<br>4.H[i] &lt;- y<br>5.if (key(y) &gt;&#x3D; key(x)) then Sift-up(H, i)<br>6.else Sift-down(H, i)<br>7.end if<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>ExtractMax(H)：删除最大元素O(log n)</p>
<p>Input: A heap H[1…n]<br>Output: An element x of maximum key is returned and deleted from the heap<br>1.x &lt;- H[1]<br>2.Delete(H, 1)<br>3.return x<br>1<br>2<br>3<br>4<br>5</p>
<h3 id="六．贪心算法（Greedy-Algorithms）"><a href="#六．贪心算法（Greedy-Algorithms）" class="headerlink" title="六．贪心算法（Greedy Algorithms）"></a>六．贪心算法（Greedy Algorithms）</h3><p>一个算法是贪婪的，如果它建立了通过每一个小步骤的解决方案，在每一小个步骤选择一个决定，以优化一些潜在的标准。<br>区间调度问题（interval scheduling）：根据完成时间排序，从小到大选择<br>下面是“Review of Greedy Algorithms”，也是贪心算法的基本思想<br>Greedy algorithms are usually designed to solve optimization problems in which a quantity is to be minimized or maximized. It typically consists of an iterative procedure that tries to find a local optimal solution. In some instances, these local optimal solutions translate to global optimal solutions. In others, they fail to give optimal solutions. A greedy algorithm makes a choice on the basis of little calculation without worrying about the future. Thus, it builds a solution step by step. Each step increases the size of the partial solution and is based on local optimization. The choice made is that which produces the largest immediate gain while maintaining feasibility. Since each step consists of little work based on a small amount of information, the resulting algorithms are typically efficient. The hard part in the design of a greedy algorithm is proving that the algorithm does indeed solve the problem it is designed for.<br>翻译：贪心算法通常被设计来解决最优化问题，即最小化或最大化一个量。它通常由一个迭代过程组成，该过程试图找到一个局部最优解。在某些实例中，这些局部最优解转变为全局最优解。在其他实例中，它们不能给出最优解。贪心算法在很少计算的基础上做出选择，并且不关心未来。因此，它逐步构建了一个解。每一步都基于局部优化增加了部分解的规模。所做出的选择，是在保持可行性的同时产生最大的即时收益。由于每一步都由基于少量信息的少量工作组成，因此产生的算法通常是有效的。贪心算法设计中的困难部分是证明该算法确实解决了它被要求解决的问题。</p>
<h3 id="七．迪杰斯特拉算法（Dijkstra’s-Algorithm）"><a href="#七．迪杰斯特拉算法（Dijkstra’s-Algorithm）" class="headerlink" title="七．迪杰斯特拉算法（Dijkstra’s Algorithm）"></a>七．迪杰斯特拉算法（Dijkstra’s Algorithm）</h3><p>注意事项：单源最短路径问题（Single-source shortest paths problem）<br>先看一道题，一个加权有向图G，采用下面哪个选项，在改动之后能保证最短路径不变。<br>A.每条边都加上17<br>B.每条边都乘以17<br>C.A和B<br>D.既不是A也不是B<br>答案是B，考虑一种情况最短路径是2条边权值分别为2和3，还有一条边是6，那么最短路径为2+3&#x3D;5，如果是A那么(2+17)+(3+17) &gt; 6+17，最短路径改变，而B选项是同时扩大，因此最短路径不变。也就是如果最短路径边数很多，那么选A，则会处于明显劣势。<br>“What’s the shortest way to travel from Rotterdam to Groningen? It is the algorithm for the shortest path, which I designed in about 20 minutes. One morning I was shopping in Amsterdam with my young fiancée, and tired, we sat down on the café terrace to drink a cup of coffee and I was just thinking about whether I could do this, and I then designed the algorithm for the shortest path. ”— Edsger Dijsktra</p>
<p>在介绍迪杰斯特拉算法之前，先说一下需要用到的函数<br>“松弛操作”中包括2个函数INITIALIZE-SINGLE-SOURCE(G, s)和RELAX(u, v, w)在第377页<br>松弛是唯一导致最短路径和前驱结点发生变化的操作<br>其他知识点都在书中，我这里就不说了</p>
<p>伪代码：<br>书中：</p>
<p>DIJKSTRA(G, w, s)<br>INITIALIZE-SINGLE-SOURCE(G, s)<br>S &#x3D; emptySet<br>Q &#x3D; G.V<br>while Q !&#x3D; emptySet<br>    u &#x3D; EXTRACT-MIN(Q)<br>    S &#x3D; S union {u}<br>    for each vertex in G.Adj[u]<br>        RELAX(u, v, w)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>自己：</p>
<p>DIJKSTRA(G, w, s)<br>for each vertex v in G.V-{s}<br>    alpha[v] &#x3D; infinity &#x2F;&#x2F; s到v的距离<br>    pi[v] &#x3D; NIL &#x2F;&#x2F; v的前驱结点<br>alpha[s] &#x3D; 0<br>Create an empty priority queue PQ &#x2F;&#x2F; 创建优先队列PQ<br>for each vertex v in G.V<br>    INSERT(PQ, v, alpha[v]) &#x2F;&#x2F; 关键值为alpha[v]<br>while PQ !&#x3D; empty<br>    u &#x3D; EXTRACT-MIN(PQ) &#x2F;&#x2F; 从优先队列中找到最小的，把u作为出发点<br>    for each edge e &#x3D; (u,v) leaving u<br>        if alpha[v] &gt; alpah[u] + le &#x2F;&#x2F; le是边的长度<br>            alpha[v] &#x3D; alpha[v] + le<br>            pi[v] &#x3D; u<br>            Reset-Key(PQ, v, alpha[v]) &#x2F;&#x2F; 修改以调整优先队列<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>时间复杂度<br>迪杰斯特拉算法的时间复杂度依赖于最小优先队列的实现。我们这里采用的是最小二叉堆。初始化即构建最小二叉堆O(n)，将每个结点从Q中删除是O(log n)那n个点是O(nlog n)，for each共执行m次，由于是二叉堆修改的时间复杂度为O(log n)，那么总共就是O(nlog n + mlog n)，由于连通图中 m &gt;&#x3D; n-1，因此总共就是O(mlog n)</p>
<p>定理、引理和推论证明<br>（1）（Dijsktra算法的正确性）Dijsktra算法运行在带权重的有向图G &#x3D; (V, E)时，如果所有权重为非负值，则在所有算法终止时，对于所有结点u属于V，我们有u.d &#x3D; 最短距离(s, u)。<br>证明：采用数学归纳法。当|S| &#x3D; 1时，因为S &#x3D; {s}并且d[s] &#x3D; 0，成立。假设当|S| &gt;&#x3D; 1时也成立。令v为下一个将要被加入到S中的结点，令u是v的在S中的前驱结点，alpha(v) &#x3D; d[u] + w(u, v)。我们只需证明没有任何一条路径的长度小于alpha(v)。考虑另外一条从s到v的路径P，令x是P中最后一个在S中的结点，令y的前驱结点为x。由于算法中是将alpha（估计值）最小的结点加入S中，因此一定有alpha(v) &lt;&#x3D; alpha(y)，那么P &#x3D; alpha(y) + P(y, v) &gt;&#x3D; alpha(y) &gt;&#x3D; alpha(v)，则d[v] &#x3D; alpha(v)一定是最小值。综上，算法是正确的。</p>
<p>注：<br>迪杰斯特拉算法生成的是最短路径树（shortest path tree）<br>为什么迪杰斯特拉算法要求权值非负呢？<br>先举一个反例，如果存在两组边分别为10和-8，3和3，那么算法就会优先选择3和3的一组边，而实际最短的是10和-8。如果权值为负，那么在上面的证明中就无法推出alpha(y) + P(y, v) &gt;&#x3D; alpha(y)，因为P(y, v)可能为负。综上，权值必须为非负的，才能保证正确性。<br>为什么迪杰斯特拉算法是一种贪心算法？<br>算法在运行时，每次都将估计值最小的结点加入集合S中。</p>
<h3 id="八．最小生成树（Minimum-Spanning-Tree）"><a href="#八．最小生成树（Minimum-Spanning-Tree）" class="headerlink" title="八．最小生成树（Minimum Spanning Tree）"></a>八．最小生成树（Minimum Spanning Tree）</h3><p>注意事项：Kruscal算法和Prim算法都是贪心算法，Kruscal算法每次加入到A中的安全边永远是连接A和A之外某个结点的边中权重最小的边，Prim算法每次加入的边都必须是使树的总权重增加量最小的边。</p>
<p>伪代码：<br>（1）Kruscal算法：</p>
<p>MST-KRUSCAL(G, w)<br>A &#x3D; emptySet<br>for each vertex v in G.V<br>    MAKE-SET(v)<br>sort the edges of G.E into nondecreasing order by weight w<br>for each edge(u, v) in G.E, taken in nondecreasing order by weight<br>    if FIND-SET(u) !&#x3D; FIND-SET(v)<br>        A &#x3D; A union {(u, v)}<br>        UNION(u, v)<br>return A<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>（2）Prim算法：</p>
<p>MST-PRIM(G, w, r)<br>for each vertex v in G.V-{s}<br>    alpha[v] &#x3D; infinity<br>    pi[v] &#x3D; NIL &#x2F;&#x2F; v的前驱结点<br>alpha[s] &#x3D; 0<br>Create an empty priority queue PQ &#x2F;&#x2F; 创建优先队列PQ<br>for each vertex v in G.V<br>    INSERT(PQ, v, alpha[v]) &#x2F;&#x2F; 关键值为alpha[v]<br>while PQ !&#x3D; empty<br>    u &#x3D; EXTRACT-MIN(PQ) &#x2F;&#x2F; 从优先队列中找到最小的<br>    for each edge e &#x3D; (u,v) 且v在PQ中<br>        if w(u, v) &lt; alpha[v]<br>            alpha[v] &#x3D; w(u, v)<br>            pi[v] &#x3D; u<br>            Reset-Key(PQ, v, alpha[v]) &#x2F;&#x2F; 修改以调整优先队列<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>3.时间复杂度<br>Kruscal算法和Prim算法都为O(mlog n)</p>
<p>4.定理、引理和推论证明<br>（1）定理：设G &#x3D; (V, E)是一个在边E上定义了实数值权重函数w的连通无向图。设集合A为E的一个子集，且A包括在图G的某棵最小生成树中，设(S, V-S)是图G中尊重集合A的任意一个切割，又设(u, v)是横跨切割(S, V-S)的一条轻量级边。那么边(u, v)对于集合A是安全的。<br>证明：设T是一棵包含A的最小生成树，如果T包含(u, v)，那么该边对A集合一定是安全的。如果T不包含(u, v)，那么由于切割(S, V-S)尊重A，而A又是T的一部分，因此一定存在从S到V-S横跨切割的一条边(x, y)，该边不在A中且是T的一部分。设u在S中，v在V-S中，那么一定存在一条从u到v的经过(x, y)的简单路径。如果形成了一棵包含(u, v)的最小生成树T’，那么(u, v)对于A一定是安全的。如果直接将(u, v)加入其中，那么会与之前从u到v经过(x, y)的简单路径形成环，因此我们必须将(x, y)删除，T会形成两个连通分量，而加入(u, v)则可以将这两个连通分量连起来形成一棵新的生成树T’，我们要证明T’是最小生成树。因为T是一棵最小生成树，因此T中边的权重之和w(T) &lt;&#x3D; w(T’)，由(u, v)是轻量边，因此有边的权重w(u, v) &lt;&#x3D; w(x, y)，则有w(T’) &lt;&#x3D; w(T)，推出w(T’) &#x3D; w(T)，即T’也是一棵最小生成树。A是T的一部分，(x, y)不是T的一部分，因此A是T’ 的一部分，所以A并上(u, v)也是T’ 的一部分，而T’ 是一棵最小生成树，那么(u, v)对于A来说一定是安全的。<br>（2）推论：设G &#x3D; (V, E)是一个连通无向图，并有定义在边集合E上的实数值权重函数w。设集合A为E的一个子集，且该子集包括在G的某棵最小生成树里，并设C &#x3D; (Vc, Ec)为森林Ga &#x3D; (V, A)中的一个连通分量（树）。如果边(u, v)是连接C和Ga中某个其他连通分量的一条轻量级边，则边(u, v)对于集合A是安全的。<br>证明：切割(Vc, V - Vc)尊重集合A，边(u, v)是横跨该切割的一条轻量级边，因此，边(u, v)对于集合A是安全的。</p>
<h3 id="九．并查集（Union-Find）"><a href="#九．并查集（Union-Find）" class="headerlink" title="九．并查集（Union Find）"></a>九．并查集（Union Find）</h3><p>并查集表示一组不连通集合的一种数据结构<br>并查集需要支持三种操作：<br>（1）MAKE-SET(x)：创造一个仅包含x的新连通分支（集合）<br>（2）FIND(x)：返回包含元素x的集合的代表元（就像是国家有主席、总统一样，代表元是该集合的代表）<br>（3）UNION(x, y)：将x和y所在的集合取并集，并用新的集合代替他们</p>
<p>令m &#x3D; 上述三种操作的总的调用次数、n &#x3D; 元素的数量</p>
<p>四种实现方式：<br>naïve linking：自然连接<br>link-by-rank：根据秩数连接<br>path compression：路径压缩<br>link-by-rank with path compression：带有路径压缩的根据秩数的连接</p>
<p>naïve linking方式<br>将第一个结点所在树的根节点连接到第二个结点所在树的根节点上</p>
<p>MAKE-SET(x)<br>parent[x] &#x3D; x</p>
<p>FIND(x)<br>while (x !&#x3D; parent[x])<br>x &#x3D; parent[x]<br>return x</p>
<p>UNION(x, y)<br>r &#x3D; FIND(x)<br>z &#x3D; FIND(y)<br>parent[r] &#x3D; z<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>定理：在最坏的情况下（形成了一个链表），一次find操作花费theta(n)时间，n是元素的数量</p>
<p>link-by-rank方式<br>每个结点保持一个整数——秩，初始时，所有集合的秩为0，在这里秩数等于树的高度。秩小的集合连接到秩大的集合中。</p>
<p>MAKE-SET(x)<br>parent[x] &#x3D; x<br>rank[x] &#x3D; 0</p>
<p>FIND(x)<br>while (x !&#x3D; parent[x])<br>x &#x3D; parent[x]<br>return x</p>
<p>UNION(x, y)<br>r &#x3D; FIND(x)<br>s &#x3D; FIND(y)<br>if (r &#x3D;&#x3D; s)<br>    return<br>else if (rank[r] &lt; rank[s])<br>    parent[r] &#x3D; s<br>else if (rank[r] &gt; rank[r])<br>    parent[s] &#x3D; r<br>else<br>    parent[r] &#x3D; s<br>    rank[s] &#x3D; rank[s] + 1  &#x2F;&#x2F; 秩相同时，将其中一个的秩+1，将另一个连过来</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>该方法的6个性质：<br>（1）如果x不是根结点，那么rank[x]不会再发生改变。<br>证明：算法中只改变根结点的秩，而非根结点不会再变为根结点。<br>（2）如果x不是根结点，那么rank[x] &lt; rank[parent[x]]。<br>证明：一个秩为k+1的根结点，只会通过两个秩为k的根结点合并产生。<br>（3）如果parent[x]改变，那么rank[parent[x]]严格增加。<br>证明：如果parent[x]改变，那么x一定是根结点，那么改变前有parent[x] &#x3D;&#x3D; x，在x改变，即被连接到新的结点r时，有rank[parent[x]] &#x3D; rank[r] &gt; rank[x]。<br>（4）任何一个秩为k的结点，在以它为根结点的树中，至少含有2^k个结点。<br>证明：当k&#x3D;0时，成立。做归纳假设，秩为k-1的节点，以它为根的树至少包含2^ (k-1）个结点。证明对秩为k的根结点依然成立。只有两个秩都为k-1的树合并，才能出现秩为k的树，根据归纳假设，这两课树至少含有2^ (k-1)个节点，合并后，至少含有2^k个结点，所以归纳假设成立。<br>（5）一个结点的秩的最大值为lower(log n)。<br>证明：有性质（4）很容易推出<br>（6）秩为k的结点数量最多为n&#x2F;2^k。<br>证明：由性质（4）任何一个秩为k的结点，在其子树中至少含有2^k个结点。秩为k的不同结点不可能含有相同的后代。</p>
<p>定理：在最坏的情况下，UNION和FIND操作，需要花费O(log n)的时间。<br>证明：这两个操作以树的高度为界，而在性质（5）中，树的高度最高为lower(log n)。</p>
<p>path compression<br>路径压缩是针对FIND操作的重新组织</p>
<p>FIND(x)<br>if (x !&#x3D; parent[x])<br>parent[x] &#x3D; FIND(parent[x])<br>return parent[x]<br>1<br>2<br>3<br>4<br>通过递归调用，将从x到根结点的路径上的所有结点的父结点都改为根结点。<br>路径压缩改变了树的结构。</p>
<p>路径压缩中不改变树的秩，此时有，height(x) &lt;&#x3D; rank[x]。</p>
<p>link-by-rank with path compression<br>link-by-rank中引入路径压缩后，那六个性质没有改变。<br>迭代log函数：</p>
<h3 id="十-动态规划（Dynamic-Programming）"><a href="#十-动态规划（Dynamic-Programming）" class="headerlink" title="十. 动态规划（Dynamic Programming）"></a>十. 动态规划（Dynamic Programming）</h3><p>动态规划历史：Bellman 动态规划的先驱<br>斐波那契数列（Fibonacci Sequence）的例子</p>
<p>&#x2F;&#x2F; 自顶向下<br>TOP-DOWN(n)<br>Initialize M[0…n] with -1 &#x2F;&#x2F; -1: unfilled<br>M[0] &lt;- 0; M[1] &lt;- 1;<br>return fibonacci(n)</p>
<p>fibonacci(j)<br>if (M[j] &#x3D;&#x3D; -1)<br>    M[j] &lt;- fibonacci(j-1) + fibonacci(j-2)<br>return M[j]</p>
<p>&#x2F;&#x2F; 自底向上<br>BOTTOM-UP(n)<br>Initialize M[0…n] with -1<br>M[0] &lt;- 0; M[1] &lt;- 1;<br>for i &#x3D; 2 to n<br>    M[i] &lt;- M[i-1] + M[i-2]</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>有向无环图中的单源最短路径问题（第24章 第2节）<br>有向无环图（directed acyclic graph DAG）<br>书中：</p>
<p>DAG-SHORTEST-PATH(G, w, s)<br>topologically sort the vertices of G<br>INITIALIZE-SINGLE-SOURCE(G, s)<br>for each vertex u, taken in topologically sorted order<br>    for each vertex v in G.Adj[u]<br>        RELAX(u, v, w)<br>1<br>2<br>3<br>4<br>5<br>6<br>自己：</p>
<p>DAG-SHORTEST-PATH(G, w, s)<br>topologically sort the vertices of G<br>for each vertex v in G.V<br>    v.d &#x3D; infinity<br>    v.pi &#x3D; NIL<br>s.d &#x3D; 0<br>for each vertex u, taken in topologically sorted order<br>    for each vertex v in G.Adj[u]<br>        if v.d &gt; u.d + w(u, v)<br>            v.d &#x3D; u.d + w(u, v)<br>            v.pi &#x3D; u<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>算法时间复杂度：拓扑排序theta(V+E)，初始化theta(V)，每条边进行了一次松弛为theta(E)，因此总运行时间为theta(V+E)</p>
<p>动态规划可以被使用，如果满足下面的条件<br>1.由多项式数量的子问题组成<br>2.原问题的解决可以简单地由子问题计算而来<br>3.从“最小”到“最大”有一个子问题的简单的顺序</p>
<p>子问题之间有清晰的相互依赖关系，这是动态规划算法的核心。如斐波那契数列、有向无环图中的单源最短路径问题</p>
<p>动态规划技术通常用于解决最优化问题</p>
<p>0-1背包问题（Knapsack problem）<br>定义：OPT(i, w) &#x3D; 在重量限制w的情况下，从1到i个物品放入背包中的最大价值。<br>目标：OPT(n, W)<br>Bellman equation</p>
<p>KNAPSACK(n, W, w1, w2, …, wn, v1, v2, …, vn)<br>for w&#x3D;0 to W<br>    M[0, w] &#x3D; 0<br>for i&#x3D;1 to n<br>    for w&#x3D;0 to W<br>        if (wi &gt; w)<br>            M[i, w] &#x3D; M[i-1, w]<br>        else<br>            M[i, w] &#x3D; max{M[i-1, w], vi+M[i-1, w-wi]}<br>return M[n, W]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>算法时间复杂度：O(nW)，但这个不是多项式时间算法。（这个解释如果大家想去了解，可以去网上搜索相关资料）</p>
<p>作业1：（1）如何通过动态规划表回溯得到最优解；（2）编程实现0-1背包动态规划算法<br>（1）</p>
<p>从(n, W)的方格向上移动，如果两个方格(i, w)与(i-1, w)的值相同，说明物体i没有放入背包；如果不相同说明物体i放入了背包中，根据Bellman equation，移动到上一行(i-1, w-wi)，按照这个规则继续下去。同则向上，不同则移动。<br>在本例中，右下角为(5, 11)值为40，向上(4, 11)仍为40，说明物体5没有放入背包中，再往上(3, 11)为25，说明物体4放入了背包中，那么11kg-6kg&#x3D;5kg，所以上一个位置移动到(3, 5)方格值为18，向上(2, 5)值为7，说明物体3放入了背包中，5kg-5kg&#x3D;0kg，因此上一个位置移动到(2, 0)方格，接下来一直到(0, 0)值没有变化，即没有新的物体放入背包中。<br>（2）<br>代码：</p>
<p>#include <iostream><br>#include <cstdio><br>using namespace std;</cstdio></iostream></p>
<p>int max(int, int);</p>
<p>int main()<br>{<br>    &#x2F;&#x2F; 输入部分<br>    int W; &#x2F;&#x2F; 背包容量<br>    int n; &#x2F;&#x2F; 物体数量<br>    cout &lt;&lt; “请输入背包容量（正整数）：”;<br>    cin &gt;&gt; W;<br>    cout &lt;&lt; “请输入物体数量（正整数）：”;<br>    cin &gt;&gt; n;<br>    int w[n+1] &#x3D; {0}; &#x2F;&#x2F; 每个物体的重量<br>    int v[n+1] &#x3D; {0}; &#x2F;&#x2F; 每个物体的价值<br>    cout &lt;&lt; “请输入物体重量和价值按照”重量 价值”输入：”;<br>    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)<br>        cin &gt;&gt; w[i] &gt;&gt; v[i];</p>
<pre><code>// 求解部分
int table[n+1][W+1]; // 动态规划表
for (int i = 0; i &lt;= W; i++)
    table[0][i] = 0;
for (int i = 1; i &lt;= n; i++)
&#123;
    for (int j = 0; j &lt;= W; j++)
    &#123;
        if (w[i] &gt; j)
            table[i][j] = table[i-1][j];
        else
            table[i][j] = max(table[i-1][j], v[i] + table[i-1][j-w[i]]);
    &#125;
&#125;
bool things[n+1] = &#123;false&#125;; // 装入背包中的物品
int k = W;
for (int i = n; i &gt;= 1; i--)
&#123;
    if (table[i][k] &gt; table[i-1][k])
    &#123;
        things[i] = true;
        k -= w[i];
    &#125;
&#125;

// 输出部分
cout &lt;&lt; &quot;动态规划表为：&quot; &lt;&lt; endl;
for (int i = 0; i &lt;= n; i++)
&#123;
    for (int j = 0; j &lt;= W; j++)
        printf(&quot;%3d &quot;, table[i][j]);
    cout &lt;&lt; endl;
&#125;
cout &lt;&lt; &quot;应该装入物品：&quot;;
for (int i = 1; i &lt;= n; i++)
&#123;
    if (things[i])
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
&#125;
cout &lt;&lt; endl;
cout &lt;&lt; &quot;最优解的值为：&quot; &lt;&lt; table[n][W] &lt;&lt; endl;

return 0;
</code></pre>
<p>}</p>
<p>int max(int i, int j)<br>{<br>    return i &gt;&#x3D; j ? i : j;<br>}</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>运行结果：</p>
<p>带有负环的最短路径问题<br>负环（negative cycle）是一个有向环，环中边的权重之和为负值。<br>正环（positive cycle）是一个有向环，环中边的权重之和为正值。（不可能出现）<br>0环是一个有向环，环中边的权重之和为0。（可以出现，但没必要）</p>
<p>引理1：如果存在从s -&gt; v的路径包含负环，那么不存在从s -&gt; v的最短路径<br>证明：如果存在这样的负环，那么可以无限的经过负环，降低路径上的权重和。<br>引理2：如果图G不存在负环，那么存在从s -&gt; v的一条简单最短路径。<br>（最短路径不含环）</p>
<p>为了解决一般的单源最短路径问题，我们将这个问题分成两个，一个是不含负环的单源最短路径问题，一个是负环的识别问题。</p>
<p>Def. OPT(i, v) &#x3D; length of shortest s -&gt; v path that uses at most i edges.<br>Goal. OPT(n-1, v) for each v.<br>（我们的目标为什么是n-1？是因为引理2，从s -&gt; v的最短路径长度至多包含n-1条边。）</p>
<p>SHORTEST-PATHS(V, E, l, s)<br>foreach node v in V:<br>    M[0, v] &lt;- infinity<br>M[0, s] &lt;- 0<br>for i &#x3D; 1 to n-1<br>    foreach node v in V:<br>        M[i, v] &lt;- M[i-1, v]<br>        foreach edge(u, v) in E<br>            M[i, v] &lt;- min{M[i, v], M[i-1, u] + luv}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>空间复杂度：O(n^2) 一个二维数组<br>时间复杂度：O(nm)<br>存储图的数据结构可以采用以入边为依据的邻接链表<br>作业2：对下图进行填表（s为出发点）</p>
<p>结果：</p>
<p>如何通过表得到顶点s到各个顶点的最短路径长度？表中最后一行就是从s到各个顶点的最短路径长度。<br>如何通过表得到顶点s到各个顶点的最短路径？其实我认为通过上面的动态规划表也是可以的，和之前的方式一样，如果发生变化就通过计算得到之前的点……。老师说可以改变算法结构，增加一个二维数组pn-1，用来记录前驱顶点，通过这个新的二维数组的最后一行就可以得到路径，但我通过检验其实一维数组p[v]也是完全可以的。但还是通过维护一个记录前驱的一维数组进行回溯方便。</p>
<p>我们可以通过维护两个一维数组，而不是维护一个二维数组<br>d[v] &#x3D; length of a shortest s-&gt;v path that we have found so far.<br>predecessor[v] &#x3D; preceding node on the above s-&gt;v path.</p>
<p>引理3：对每一个顶点，d[v]是单调非递增的。<br>引理4：在第i次迭代后，d[v]是当前从s-&gt;v用最多i条边的最短路径长度。<br>证明：当i &#x3D; 0时成立。假设第i次后，成立。那么在第i+1次后，令p是另一个从s-&gt;v的含有最多i+1条边的路径，令u是v的前驱顶点，那么从s-&gt;u最多包含i条边，设从s-&gt;u的任意路径为p’，那么根据归纳假设有d[u] &lt;&#x3D; l(p’)，因此有d[v] &#x3D; d[u] + luv &lt;&#x3D; l(p’ ) + luv &#x3D; l(p )，所以假设成立。（这个证明很重要）</p>
<p>推论：如果最短路径含有k条边，那么算法可以在最多k次迭代后找到最短路径。<br>定理2：假设没有负环，Bellman-Ford计算从s-&gt;v的最短路径，时间复杂度为O(mn)，空间复杂度为theta(n)<br>证明：引理2+引理4</p>
<p>负环检测问题（Detecting negative cycles）<br>先用Bellman-Ford算法迭代n-1次，接着再迭代1次，如果最短路径长度继续减小，说明一定含有负环。</p>
<p>引理5：对于每个结点v，如果有OPT(n, v) &#x3D; OPT(n-1, v)，那么没有负环。<br>证明：</p>
<p>（OPT(n+1, v)的推导中，OPT(n-1, u) + luv &#x3D; OPT(n, v)，因此得到最后的结果。这是老师给的证明方法，更为直观一些，但用归纳法证明更好。）<br>引理6：如果对某些结点有OPT(n, v) &lt; OPT(n-1, v)，那么从s-&gt;v的长度为n最短路径一定含有环W，且是负环。<br>证明：如果OPT(n, v) &lt; OPT(n-1, v)，任何s-&gt;v的最短路p，最多含有n条边，实际上更准确的是含有n条边，否则OPT(n, v) &#x3D; OPT(n-1, v)。由鸽巢原理，路径p一定包含重复的结点x，令W为路径p中的环，如果W不是负环，那么删除W，则s-&gt;v最多有n-1条边并且有OPT(n, v) &#x3D; OPT(n-1, v)。此时产生矛盾，因此W是负环。<br>引理6的逆否命题：引理6’：如果不含负环，那么对于每个结点有OPT(n, v) &#x3D; OPT(n-1, v)。</p>
<p>定理4：如果对于每个结点v有OPT(n, v) &#x3D; OPT(n-1, v)，当且仅当不含负环。<br>证明：引理5 + 引理6’<br>定理5：能够在theta(mn)的时间内，找到一个负环。</p>
<p>BELLMAN-FORD(V, E, l, s)<br>foreach node v in V:<br>    d[v] &lt;- infinity<br>    predecessor[v] &lt;- null<br>d[s] &lt;- 0<br>for i &#x3D; 1 to n-1:<br>    foreach node v in V:<br>        foreach edge(u, v) in E:<br>            if (d[v] &gt; d[u] + luv)<br>                d[v] &lt;- d[u] + luv<br>                predecessor[v] &lt;- u<br>foreach edge(u, v) in E:<br>    if (d[v] &gt; d[u] + luv)<br>        return true &#x2F;&#x2F; 含有负环<br>return false &#x2F;&#x2F; 不含有负环<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>十一. 所有结点对之间的最短距离（All-pairs Shortest-Paths Problem）<br>给一个nxn的权值矩阵W，表示有向图G &#x3D; (W, E)边的权值。输出一个距离矩阵D &#x3D; (dij)，表示顶点i和顶点j之间的距离。<br>定义：Lij(m) &#x3D; i -&gt; j 的路径且最多含有m条边<br>目标：Lij(n-1) 每一对顶点i和j<br>（不能含有负环）<br>lij(m)表示，从 i 到 j 最多含有m条边的最短路长度</p>
<p>伪代码：</p>
<p>ALL-PAIRS-SHORTEST-PATHS(W)<br>n &#x3D; W.rows<br>L(1) &#x3D; W<br>for m &#x3D; 2 to n-1<br>    let L(m) be a new n x n matrix<br>    L(m) &#x3D; EXTEND-SHORTEST-PATHS(L(m-1), W)<br>return L(n-1)</p>
<p>EXTEND-SHORTEST-PATHS(L, W)<br>n &#x3D; L.rows<br>let L’ &#x3D; (Lij’) be a new n x n matrix<br>for i &#x3D; 1 to n<br>    for j &#x3D; 1 to n<br>        Lij’ &#x3D; infinity<br>        for k &#x3D; 1 to n<br>            Lij’ &#x3D; min(Lij’, Lik + wkj)<br>return L’</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>时间复杂度 O(n^4)</p>
<p>Lij(m) &#x3D; min{Lik(m-1) + wkj | 1 &lt;&#x3D; k &lt;&#x3D; n}，这个我感觉很漂亮，很像矩阵相乘</p>
<p>我去，和我想的一样</p>
<p>Lij(4) &#x3D; min{Lik(2) + Lkj(2) | 1 &lt;&#x3D; k &lt;&#x3D; n}</p>
<p>改进后的算法只有主过程需要改进（看明白）<br>当最后一次进入主过程的循环时，2m &gt; n-1，由第十部分动态规划中的Bellman-Ford算法，我们已经知道，此时的Lij(2m)已经收敛等于Lij(n-1)<br>（不能含有负环）</p>
<p>ALL-PAIRS-SHORTEST-PATHS(W)<br>n &#x3D; W.rows<br>L(1) &#x3D; W<br>m &#x3D; 1<br>while m &lt; n - 1<br>    let L(2m) be a new n x n matrix<br>    L(2m) &#x3D; EXTEND-SHORTEST-PATHS(L(m), L(m))<br>    m &#x3D; 2m<br>return L(m)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>时间复杂度 O(n^3 logn)</p>
<p>Floyd-Warshall Algorithm<br>定义：dij(k) &#x3D; i -&gt; j的最短路径长度，其中间结点的下标取自{1, 2, …, k}中（下标）<br>目标：对于每一对结点i和j计算dij(n)<br>第k个结点不在路径中，第k个结点在路径中。只有这两种可能。<br>（不能含有负环）</p>
<p>伪代码：</p>
<p>FLOYD-WARSHALL ALGORITHM<br>n &#x3D; W.rows<br>D(0) &#x3D; W<br>for k &#x3D; 1 to n<br>    let D(k) &#x3D; (dij(k)) be a new n x n matrix<br>    for i &#x3D; 1 to n<br>        for j &#x3D; 1 to n<br>            dij(k) &#x3D; min(dij(k-1), dik(k-1) + dkj(k-1))<br>return D(n)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>时间复杂度 O(n^3)</p>
<p>可以含有负环的算法：Johnson’s ALgorithm</p>
<p>十二. 流网络（Flow Network）<br>应用例子：图像分割（image segmentation）、社区发现（community detection）一个流网络是一个多元组G &#x3D; (V, E, s, t, c)，前两个代表有向图V是顶点集合，E是边集合，s和t是两个特殊的顶点，s（source）是原点，t（sink）是汇点，c是容量，将一条边映射为一个实数并且对于E中的任意一条边e，有c(e) &gt;&#x3D; 0。</p>
<p>流是一个函数，满足两个约束即流量约束和流守恒约束。<br>容量约束（capacity constraints）：对于E中的每一个e，有0 &lt;&#x3D; f(e) &lt;&#x3D; c(e)<br>流守恒约束（flow conservation constraints）：对于V中的每一个点v（不包括s和t），有<br>∑ e   i n t o   v f ( e ) &#x3D; ∑ e   o u t   o f   v f ( e ) \sum{e , into , v}f(e) &#x3D; \sum{e , out , of , v}f(e)<br>eintov<br>∑</p>
<p> f(e)&#x3D;<br>eoutofv<br>∑</p>
<p> f(e)<br>如果定义<br>inflow at v &#x3D; fin(v)<br>outflow at v &#x3D; fout(v)<br>则有对于每个结点（不包括s和t）则有fin(v) &#x3D; fout(v)<br>流的值：val(f) &#x3D; ∑ e   o u t   o f   s f ( e ) − ∑ e   i n t o   s f ( e ) \sum{e , out , of , s}f(e) - \sum{e , into , s}f(e)∑<br>eoutofs</p>
<p> f(e)−∑<br>eintos</p>
<p> f(e)<br>（注意下标）</p>
<p>最大流问题（Max-flow problem）<br>即最大化val(f)</p>
<p>最小割问题（Min-cut problem）<br>（最大流问题和最小割问题是对偶问题，即解决其中一个就解决了另一个）<br>定义：一个割是顶点集合V的二划分(A, B)，s in A，t in B<br>定义：割的容量c a p ( A , B ) &#x3D; ∑ e   o u t   o f   A c ( e ) cap(A,B)&#x3D;\sum_{e , out, of, A}c(e)cap(A,B)&#x3D;∑<br>eoutofA</p>
<p> c(e)<br>（直观理解：A中的顶点为黑点，B中的顶点为白点，割的容量指的是从黑点到白点的边的容量之和，不考虑从白点到黑点）<br>最小割问题是找一个容量最小的割</p>
<p>（贪心算法无法解决max-flow problem）</p>
<p>这个贪心算法fail，不能找到最优值（Augment被翻译为“增广”）<br>Q:Why fails?<br>A:一旦贪心算法增加了某条边的流量，就再也不能减小，无法undo<br>Solution:需要采取某种机制undo一个之前不好的选择</p>
<p>剩余网络（残差网络）（Residual network）</p>
<p>原网络G、剩余网络Gf、forward edge（前向边）、backward edge（后向边、反向边）<br>定义：一条增广路径（augmenting path）是在剩余网络中一条s -&gt; t的简单路径<br>定义：增广路径P的瓶颈容量（bottleneck capacity）是剩余网络路径P上的边最小容量<br>增广操作：根据增广路径来调整值的操作<br>令f为流，P为Gf中的增广路径，调用f’ &lt;- AUGMENT(f, c, P)，结果f’是一个流并且val(f’) &#x3D; val(f) + bottleneck(Gf, P)</p>
<p>AUGMENT(f, c, P)<br>temp &lt;- bottleneck capacity of augmenting path P.<br>foreach edge e in P:<br>    if e in E<br>        f(e) &lt;- f(e) + temp<br>    else if e not in E and e in Ef<br>        f(e) &lt;- f(e) - temp<br>return f<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>增广操作之后原网络G仍满足容量守恒和流约束守恒<br>This is easy to see. f ’ respects the capacity constraints since we never increased the flow beyond the residual capacity of any arc. Flow conservation constraints are still satisfied since flow is augmented along a path from s to t, and for any node other than s or t along the path, the flow entering the node, and the flow leaving the node both increase by δ. Finally, the s-t flow increases by δ since the net flow out of s increases by δ.<br>f’满足容量守恒，因为我们从未增加到超过剩余网络任意一条边容量的流量。流约束守恒也是满足的，因为流是通过s -&gt; t的增广路径执行的增广操作而改变，并且在增广路径P上除s和t之外的任意一点，流入结点的流量和流出结点的流量都增加了相同的瓶颈容量temp。最后，s -&gt; t的流增加了temp，因为离开s的流增加了temp<br>Ford-Fulkerson Algorithm</p>
<p>（剩余网络上没有s-&gt;t的增广路径即结束）</p>
<p>FORD-FULKERSON(G)<br>foreach edge e in E<br>    f(e) &lt;- 0<br>Gf &lt;- residual network of G with respect to flow f<br>while (there exists an s -&gt; t path P in Gf)<br>    Gf(p) &#x3D; min{Gf(u, v): (u, v) in P}<br>    for each edge (u, v) in P<br>        if (u, v) in E<br>            f(u, v) &#x3D; f(u, v) + Gf(P)<br>        else<br>            f(u, v) &#x3D; f(u, v) - Gf(P)<br>    Update Gf<br>return f<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>该算法没有深入发掘网络的结构，即在选择增广路径时太随意，导致其时间复杂度不好，为伪多项式时间算法</p>
<p>引理：流值引理（Flow value lemma）：令f为任意一个网络流，令(A, B)为任意一个割。那么，流f的值等于穿过割(A, B)的流量，即<br>v a l ( f ) &#x3D; ∑ e   o u t   o f   s f ( e ) − ∑ e   i n t o   s f ( e ) &#x3D; ∑ v   ∈   A ( ∑ e   o u t   o f   v f ( e ) − ∑ e   i n t o   v f ( e ) ) &#x3D; ∑ e   o u t   o f   A f ( e ) − ∑ e   i n t o   A f ( e ) val(f) &#x3D; \sum{e , out, of, s}f(e)-\sum{e, into, s}f(e) &#x3D;\sum{v, \in,A}(\sum{e, out, of, v}f(e)-\sum{e, into, v}f(e)) &#x3D; \sum{e, out, of, A}f(e)-\sum_{e, into, A}f(e)val(f)&#x3D;∑<br>eoutofs</p>
<p> f(e)−∑<br>eintos</p>
<p> f(e)&#x3D;∑<br>v∈A</p>
<p> (∑<br>eoutofv</p>
<p> f(e)−∑<br>eintov</p>
<p> f(e))&#x3D;∑<br>eoutofA</p>
<p> f(e)−∑<br>eintoA</p>
<p> f(e)（注意下标）<br>（注意 割的容量 和 穿过割的流量 的区别）<br>第二个等号成立：根据流约束守恒，A中所有顶点除了s的都为0（s in A，t in B）<br>（剩余网络中容量为0的边，我们一般不画，因为对问题的解决毫无贡献）</p>
<p>弱对偶定理（Weak duality）：令f为任意一个流，(A, B)为任意一个割，那么val(f) &lt;&#x3D; cap(A, B)<br>证明：val(f) &#x3D; ∑ e   o u t   o f   A f ( e ) − ∑ e   i n t o   A f ( e ) &lt; &#x3D; ∑ e   o u t   o f   A f ( e ) &lt; &#x3D; ∑ e   o u t   o f   A c ( e ) &#x3D; c a p ( A , B ) \sum{e, out, of, A}f(e) - \sum{e, into, A}f(e) &lt;&#x3D; \sum{e, out, of, A}f(e) &lt;&#x3D; \sum{e, out, of, A}c(e) &#x3D; cap(A, B)∑<br>eoutofA</p>
<p> f(e)−∑<br>eintoA</p>
<p> f(e)&lt;&#x3D;∑<br>eoutofA</p>
<p> f(e)&lt;&#x3D;∑<br>eoutofA</p>
<p> c(e)&#x3D;cap(A,B)<br>结论：令f为一个流，令(A, B)为一个割，如果val(f) &#x3D; cap(A, B)，那么f是最大流并且(A, B)是一个最小割。<br>证明：对于任意一个流f’: val(f’) &lt;&#x3D; cap(A, B) &#x3D; val(f)<br>对于任意一个割(A’, B’): cap(A’, B’) &gt;&#x3D; val(f) &#x3D; cap(A, B)</p>
<p>最大流最小割定理（max-flow min-cut theorem）：最大流的值等于最小割的容量。<br>增广路径定理（augmenting path theorem）（非常重要）：一个流f是最大流，当且仅当没有增广路径。<br>对于任意一个流f下面的三个条件是等价的：<br>i. 有一个割(A, B)，且cap(A, B) &#x3D; val(f)<br>ii. f是最大流<br>iii. 剩余网络中不存在增广路径<br>证明：<br>i -&gt; ii: 根据弱对偶定理val(f) &lt;&#x3D; cap(A, B)，而cap(A, B) &#x3D; val(f)，故f是最大流<br>ii -&gt; iii: 假设此时在剩余网络中还存在增广路径，那么我们可以通过增广路径进一步地增大流f，与已知f是最大流矛盾，因此得证<br>iii-&gt; i: 令f是一个不存在增广路径的流，令A是一组在剩余网络中从s出发可达的顶点集合，其余顶点构成集合B，则有一个割(A, B)。令e &#x3D; (u, v)是横跨切割(A, B)的一条边。如果u在A中且v在B中，那么f(e) &#x3D; c(e)（如果f(e) &lt; c(e)，那么在剩余网络中存在一条从u -&gt; v的边，使s -&gt; v可达，而s -&gt; v不可达，因此f(e) &#x3D; c(e)），如果u在B中且v在A中，那么f(e) &#x3D; 0（如果f(e) &gt; 0，那么在剩余网路中存在从则存在v-&gt; u的边，使s -&gt; u可达，而s -&gt; u不可达，因此f(e) &#x3D; 0）。由流值定理v a l ( f ) &#x3D; ∑ e   o u t   o f   A f ( e ) − ∑ e   i n t o   A f ( e ) &#x3D; ∑ e   o u t   o f   A c ( e ) − 0 &#x3D; c a p ( A , B ) val(f) &#x3D; \sum{e, out, of, A}f(e) - \sum{e, into, A}f(e) &#x3D; \sum_{e, out, of, A}c(e) - 0 &#x3D; cap(A, B)val(f)&#x3D;∑<br>eoutofA</p>
<p> f(e)−∑<br>eintoA</p>
<p> f(e)&#x3D;∑<br>eoutofA</p>
<p> c(e)−0&#x3D;cap(A,B)，得证。</p>
<p>时间复杂度分析：<br>假设1：每条边的容量都是整数（这个假设是合理的，若是无理数可能存在无法收敛的情况，可以自己再去了解相关信息）<br>假设2：每条边的容量在1和C之间<br>Ford-Fulkerson每次迭代至少增加1，那么val(f) &lt;&#x3D; nC即O(nC)，考虑一种极端的情况，s和t之外的每个顶点的前驱顶点为s，后继顶点为t，那么为(n-2)C。在剩余网络上找一条增广路径可以用BFS或DFS，二者的时间复杂度都为O(m+n)，因此总的时间复杂度为O(mnc - n^2C) &#x3D; O(mnC)，因为m &gt; n，因此忽略n^2C。这个算法的时间复杂度不是多项式时间算法，是伪多项式时间算法，因为有C存在，这和之前背包算法中的类似。</p>
<p>十三. NP完全性（NP Completeness）<br>十二．NP完全性（NP Completeness）<br>问题有两种描述方式，优化模式（Optimization Problem）和判别模式（Decision Problem）</p>
<p>归约：一个步骤f，可以将问题A的任何一个实例都转换成问题B的实例并且要满足下面的两个要求。<br>Transformation：这个转换过程必须在多项式时间内完成。<br>Equivalence：一个实例或一个项，必须同时为YES或NO。<br>（注意下面的定义，“问题A可以在多项式时间内被归约为问题B”，小p指的是多项式时间）</p>
<p>定理：如果问题B可以在多项式时间内被解决，那么A也可以在多项式时间内被解决。<br>证明：<br>（1）给定一个问题A的一个实例alpha，使用多项式时间归约为beita &#x3D; f(alpha)<br>（2）运用B的多项式时间算法，解决实例beita &#x3D; f(alpha)<br>（3）使用beita的答案作为alpha的答案</p>
<p>定理：相反地，如果A不存在多项式时间算法，那么B也不存在多项式时间算法（该定理是之前定理的逆否命题）</p>
<p>题：</p>
<p>选C。C就是之前说的逆否命题。D不行，因为X可能存在一个多项式时间算法，但通过归约后的Y可以不存在多项式时间算法。</p>
<p>Vertex Cover顶点覆盖问题<br>输入：一个图G &#x3D; (V, E)和一个整数k<br>输出：是否存在一个顶点集合S属于V，|S| &#x3D; k，使得每条边至少和这k个顶点中的一个相关联，能找到为YES，找不到为NO<br>Set Cover集合覆盖问题<br>输入：一个含有n个元素的集合U &#x3D; {e1, e2, …, en}，给一系列的m个子集S &#x3D; {S1, S2, …, Sm}，和一个整数k<br>输出：是否存在一个集合C属于S，使得C中各集合的元素的并集为U并且|C| &lt;&#x3D; k，存在为YES，不存在为NO</p>
<p>定理：顶点覆盖问题可以在多项式时间内归约为集合覆盖问题<br>证明：给一个顶点集合实例G &#x3D; (V, E)和k，我们构造一个集合覆盖实例(U, S, k)，使得S中的k个集合能够覆盖U，当且仅当G有一个大小为k的顶点集合覆盖。<br>构造（Construction）：<br>·令U &#x3D; E<br>·对于V中的每一个v，构造一个集合Sv &#x3D; {e属于E，e关联于v}<br>（简单点说，就是E中的每一条边就是U中的每一个元素，V中的每个顶点就是S中的每个集合，V中顶点关联的边就是S中集合的元素）</p>
<p>断言（Claim）：G &#x3D; (V, E)有一个大小为k的顶点覆盖当且仅当(U, S)有一个大小为k的集合覆盖<br>证明：<br>&#x3D;&gt;<br>令X是V的子集，是一个在G中大小为k的顶点覆盖<br>令Y &#x3D; {Sv : v属于X}是一个大小为k的集合覆盖<br>&lt;&#x3D;<br>令Y属于S，是一个大小为k的集合覆盖<br>令X &#x3D; {v : Sv属于Y}是一个在G中大小为k的顶点覆盖</p>
<p>Construction + Claim &#x3D;&gt; 顶点覆盖可以在多项式时间内归约为集合覆盖<br>（也就是说顶点覆盖比集合覆盖在计算上更容易，因此用式子表示式小于等于号）</p>
<p>3SAT问题（3-SATISFIABILITY Problem）</p>
<p>3SAT Problem是SAT问题的特殊情况，即每一个子句中恰好包含了3个文字</p>
<p>独立集问题（Independent Set Problem）<br>输入：给定一个图G &#x3D; (V, E)，和一个整数k<br>输出：是否存在一组顶点的集合S属于V，|S| &#x3D; k，使得没有在S中没有两个顶点由一条边相连（即集合S中的k个顶点，两两不相邻）</p>
<p>定理：3SAT问题可以在多项式时间内归约为独立集问题</p>
<p>证明：给定一个3SAT问题的实例，我们构造一个独立集问题(G, k)，其有一个大小为k的独立集，当且仅当3SAT问题的实例是可满足的<br>构造（Construction）：<br>·每个子句中的1个文字对应1个顶点<br>·每个子句中的3个文字所对应的3个顶点，两两相邻，构成一个三角<br>·不同子句间互为相反的文字连接起来</p>
<p>断言（Claim）：Φ \PhiΦ是可满足的，当且仅当G有一个大小为k &#x3D; ∣ Φ ∣ |\Phi|∣Φ∣的独立集<br>（注：k为子句的数量，在本例中k &#x3D; 4）<br>&#x3D;&gt;：<br>由于3SAT为TRUE，那么每个子句中至少有一个为TRUE，从每个子句中选择一个为真的文字为顶点。选中的顶点不可能处于同一个三角（每个三角只选择一个顶点）并且不同三角中的顶点不可能相邻（相邻的都是互为相反的），这些顶点构成了一个大小为k的独立集。<br>&lt;&#x3D;：<br>令S是一个大小为k的独立集，因此任意两个顶点不可能处于同一个三角。那么每个三角对应的子句都为TRUE，3SAT问题为TRUE</p>
<p>&lt;&#x3D;p 是一个偏序关系，满足自反、反对称和传递。</p>
<p>P类（P Class）<br>可以在多项式时间内解决的问题（排序、最小生成树、拓扑排序、遍历问题、最短路径问题）</p>
<p>NP类（NP Class）<br>一种定义：比P类问题要求低。给一个解，可以在多项式时间内验证是否正确的问题。<br>另一种定义：Nondeterministic Polynomial time非确定多项式时间。在非确定图灵机上在多项式时间内求解 对应于 在图灵机上多项式时间验证。</p>
<p>P类问题是NP类问题的一个子集。</p>
<p>关键的问题是：P &#x3D;&#x3D; NP？</p>
<p>NP完全问题的定义要记住。</p>
<p>感受<br>这门课实在是太棒了，大爱《算法导论》，大爱“算法设计与分析”这门课。刘老师讲的也非常好，非常感谢！剩余没讲的内容，我会在之后一点点学完。我复习所根据的就是这个笔记，希望能对大家有所帮助。<br>————————————————<br>版权声明：本文为CSDN博主「ALTLI」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43360801/article/details/104919754">https://blog.csdn.net/weixin_43360801/article/details/104919754</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jcvvv.github.io">锦尘</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/">https://jcvvv.github.io/2023/03/25/Algorithm%20knowledge%20summary/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jcvvv.github.io" target="_blank">锦尘</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/sql/">sql</a></div><div class="post_share"><div class="social-share" data-image="/pic/cover/18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/27/Data%20visualization%20course%20design/"><img class="prev-cover" src="/pic/cover/19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据可视化课设</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/20/Database%20summary/"><img class="next-cover" src="/pic/cover/17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据库知识点汇总</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/27/Data%20visualization%20course%20design/" title="数据可视化课设"><img class="cover" src="/pic/cover/19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-27</div><div class="title">数据可视化课设</div></div></a></div><div><a href="/2023/03/20/Database%20summary/" title="数据库知识点汇总"><img class="cover" src="/pic/cover/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">数据库知识点汇总</div></div></a></div><div><a href="/2023/03/14/Operating%20system%20summary/" title="操作系统知识点汇总"><img class="cover" src="/pic/cover/16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-14</div><div class="title">操作系统知识点汇总</div></div></a></div><div><a href="/2023/03/30/Database%20experiments/" title="数据库实验"><img class="cover" src="/pic/cover/20.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-30</div><div class="title">数据库实验</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">锦尘</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JCvvv" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/475586532?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="mailto:1747624698@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88Breadth-first-Search%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">一．广度优先搜索（Breadth-first Search）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8E%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88Depth-first-Search%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">二．深度优先搜索（Depth-first Search）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88Topological-Sort%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">三．拓扑排序（Topological Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8E%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%88Strongly-Connected-Components%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">四．强连通分量（Strongly Connected Components）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%EF%BC%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88Priority-Queue%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">五．优先级队列（Priority Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%EF%BC%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88Greedy-Algorithms%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">六．贪心算法（Greedy Algorithms）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%EF%BC%8E%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%EF%BC%88Dijkstra%E2%80%99s-Algorithm%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">七．迪杰斯特拉算法（Dijkstra’s Algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%EF%BC%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88Minimum-Spanning-Tree%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">八．最小生成树（Minimum Spanning Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%EF%BC%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88Union-Find%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">九．并查集（Union Find）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic-Programming%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">十. 动态规划（Dynamic Programming）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/28/Github%20Profile/" title="GitHub Profile美化">GitHub Profile美化</a><time datetime="2023-07-27T16:00:00.000Z" title="发表于 2023-07-28 00:00:00">2023-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/14/Marxist%20interview%20report/" title="马克思主义访谈报告">马克思主义访谈报告</a><time datetime="2023-07-13T16:00:00.000Z" title="发表于 2023-07-14 00:00:00">2023-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/14/Principles%20of%20Marxism/" title="马克思主义原理题库">马克思主义原理题库</a><time datetime="2023-07-13T16:00:00.000Z" title="发表于 2023-07-14 00:00:00">2023-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/11/Database%20coursework/" title="数据库课程设计">数据库课程设计</a><time datetime="2023-07-10T16:00:00.000Z" title="发表于 2023-07-11 00:00:00">2023-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/Get%20started%20with%20MongoDB/" title="MongoDB入门">MongoDB入门</a><time datetime="2023-07-06T16:00:00.000Z" title="发表于 2023-07-07 00:00:00">2023-07-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/foot.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 锦尘</div><div class="footer_custom_text">欢迎你，不知道从哪来的朋友</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>