<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统实验 | 锦尘</title><meta name="keywords" content="linux,操作系统"><meta name="author" content="锦尘"><meta name="copyright" content="锦尘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="概述第一次实验的主要任务是熟悉实验指导书第一部分，关于操作系统命令实验；第二次实验开始，每周完成一个实验，对应实验指导书中第二部分操作系统算法实验中的实验一至实验五，以及实验七。 以压缩包的形式提交实验报告、相应的代码以及实验结果录屏（只交独立实验的），打包文件包括：实验报告+代码+录屏，命名方式为：“学号-姓名-实验X”。 实验报告提交：ftp:&#x2F;&#x2F;student:sc.sdu.edu.cn@2">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统实验">
<meta property="og:url" content="https://jcvvv.github.io/2023/04/01/Operating%20system%20experiments/index.html">
<meta property="og:site_name" content="锦尘">
<meta property="og:description" content="概述第一次实验的主要任务是熟悉实验指导书第一部分，关于操作系统命令实验；第二次实验开始，每周完成一个实验，对应实验指导书中第二部分操作系统算法实验中的实验一至实验五，以及实验七。 以压缩包的形式提交实验报告、相应的代码以及实验结果录屏（只交独立实验的），打包文件包括：实验报告+代码+录屏，命名方式为：“学号-姓名-实验X”。 实验报告提交：ftp:&#x2F;&#x2F;student:sc.sdu.edu.cn@2">
<meta property="og:locale">
<meta property="og:image" content="https://jcvvv.github.io/pic/cover/21.jpg">
<meta property="article:published_time" content="2023-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2023-07-31T07:15:45.932Z">
<meta property="article:author" content="锦尘">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jcvvv.github.io/pic/cover/21.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jcvvv.github.io/2023/04/01/Operating%20system%20experiments/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统实验',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-31 15:15:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/pic/cover/21.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">锦尘</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa-solid fa-image"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统实验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-31T16:00:00.000Z" title="发表于 2023-04-01 00:00:00">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-31T07:15:45.932Z" title="更新于 2023-07-31 15:15:45">2023-07-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E9%AA%8C/">实验</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16,130</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统实验"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>第一次实验的主要任务是熟悉实验指导书第一部分，关于操作系统命令实验；第二次实验开始，每周完成一个实验，对应实验指导书中第二部分操作系统算法实验中的实验一至实验五，以及实验七。</p>
<p>以压缩包的形式提交<strong>实验报告、相应的代码以及实验结果录屏（只交独立实验的）</strong>，打包文件包括：<strong>实验报告+代码+录屏</strong>，命名方式为：“<strong>学号-姓名-实验X</strong>”。</p>
<p>实验报告提交：<a href="ftp://student:sc.sdu.edu.cn@211.87.227.230:230/">ftp://student:sc.sdu.edu.cn@211.87.227.230:230</a></p>
<p>实验环境：白嫖的阿里云centos服务器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure>



<h2 id="实验一-进程控制实验"><a href="#实验一-进程控制实验" class="headerlink" title="实验一 进程控制实验"></a>实验一 进程控制实验</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>加深对于进程并发执行概念的理解。实践并发进程的创建和控制方法。观察和体验进程的动态特性。进一步理解进程生命期期间创建、变换、撤销状态变换的过程。掌握进程控制的方法，了解父子进程间的控制和协作关系。练习 Linux 系统中进程创建与控制有关的系统调用的编程和调试技术。</p>
<h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><p>1.与进程创建、执行有关的系统调用说明  </p>
<p>进程可以通过系统调用fork()创建子进程并和其子进程并发执行.子进程初始 的执行映像是父进程的一个复本.子进程可以通过 exec()系统调用族装入一个新 的执行程序。父进程可以使用 wait()或 waitpid()系统调用等待子进程的结束并负 责收集和清理子进程的退出状态。 </p>
<p>fork()系统调用语法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>   </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;  </span><br></pre></td></tr></table></figure>

<ul>
<li>fork 成功创建子进程后将返回子进程的进程号,不成功会返回-1.</li>
</ul>
<p>exec 系统调用有一组 6 个函数,其中示例实验中引用了 execve 系统调用语法:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> * envp[])</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>path 要装入的新的执行文件的绝对路径名字符串. </p>
</li>
<li><p>argv[] 要传递给新执行程序的完整的命令参数列表(可以为空).  </p>
</li>
<li><p>envp[] 要传递给新执行程序的完整的环境变量参数列表(可以为空).  </p>
</li>
<li><p>Exec 执行成功后将用一个新的程序代替原进程，但进程号不变，它绝不会再返回到调用进程了。如果 exec 调用失败，它会返回-1。</p>
</li>
</ul>
<p>wait() 系统调用语法: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> option)</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>status 用于保留子进程的退出状态</li>
</ul>
<p>pid 可以为以下可能值：</p>
<table>
<thead>
<tr>
<th align="center">pid</th>
<th align="center">详解</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-1</td>
<td align="center">等待所有 PGID 等于 PID 的绝对值的子进程</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">等待所有子进程</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">等待所有 PGID 等于调用进程的子进程</td>
</tr>
<tr>
<td align="center">&gt;0</td>
<td align="center">等待 PID 等于 pid 的子进程</td>
</tr>
</tbody></table>
<p>　　</p>
<p>option 规定了调用 waitpid 进程的行为： </p>
<ul>
<li><p>WNOHANG 没有子进程时立即返回 </p>
</li>
<li><p>WUNTRACED 没有报告状态的进程时返回</p>
</li>
</ul>
<p>wait 和 waitpid 执行成功将返回终止的子进程的进程号，不成功返回-1。</p>
<p> getpid()系统调用语法:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="type">void</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getpid 返回当前进程的进程号</p>
</li>
<li><p>getppid 返回当前进程父进程的进程号</p>
</li>
</ul>
<p>2.与进程控制有关的系统调用说明 </p>
<p>可以通过信号向一个进程发送消息以控制进程的行为。信号是由中断或 异常事件引发的，如：键盘中断、定时器中断、非法内存引用等。信号的名字都以 SIG 开头，例如 SIGTERM、SIGHUP。可以使用 kill -l 命令查看 系统当前的信号集合。 </p>
<p>信号可在任何时间发生，接收信号的进程可以对接收到的信号采取3种处理措施之一：</p>
<ul>
<li>忽略这个信号</li>
<li>执行系统默认的处理</li>
<li>捕捉这个信号做自定义的处理</li>
</ul>
<p>信号从产生到被处理所经过的过程： </p>
<blockquote>
<p>产 生 (generate)-&gt; 挂 起 (pending)-&gt; 派 送 (deliver)-&gt; 部 署 (disposition) 或 忽 略 (igore)  </p>
</blockquote>
<p>一个信号集合是一个 C 语言的 sigset_t 数据类型的对象，sigset_t 数据类 型定义在中。被一个进程忽略的所有信号的集合称为一个信号掩 码(mask)。 </p>
<p>从程序中向一个进程发送信号有两种方法：调用 shell 的 kill 命令，调 用kill系统调用函数。kill能够发送除杀死一个进程(SIGKILL、SIGTERM、 SIGQUIT)  之外的其他信号，例如键盘中断(Ctrl+C)信号 SIGINT,进程暂停(Ctrl+Z)信号 SIGTSTP 等等。 </p>
<p>调用 Pause 函数会令调用进程的执行挂起直到一个任意信号到来后再继 续运行。 </p>
<p>调用 sleep 函数会令调用进程的执行挂起睡眠指定的秒数或一个它可以 响应的信号到来后继续执行。 </p>
<p>每个进程都能使用 signal 函数定义自己的信号处理函数，捕捉并自行处 理接收的除 SIGSTOP 和 SIGKILL 之外的信号。以下是有关的系统调用的语 法说明。 </p>
<p>kill 系统调用语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pid 接收信号的进程号 </p>
</li>
<li><p>signal 要发送的信号  </p>
</li>
<li><p>kill 发送成功返回接收者的进程号，失败返回-1。</p>
</li>
</ul>
<p>pause 系统调用语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;unistd.h&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pause</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>pause 挂起调用它的进程直到有任何信号到达。调用进程不自定义处理方法，则进行信号的默认处理。</li>
<li>只有进程自定义了信号处理方法捕获并处理了一个信号后，pause 才会返回调进程。pause 总是返回-1，并设置系统变量 errno 为 EINTR。</li>
</ul>
<p>sleep 系统调用语法： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;  </span><br></pre></td></tr></table></figure>

<ul>
<li>seconds 指定进程睡眠的秒数 如果指定的秒数到，sleep 返回 0。</li>
</ul>
<p>signal 系统调用语法为:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;signal.h&gt;</span>    </span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>signum 要捕捉的信号 </p>
</li>
<li><p>handler 进程中自定义的信号处理函数名 </p>
</li>
<li><p>signal 调用成功会返回信号处理函数的返回值，不成功返回-1,并设置系统变量 errno 为 SIG_ERR。</p>
</li>
</ul>
<h3 id="独立实验"><a href="#独立实验" class="headerlink" title="独立实验"></a>独立实验</h3><p>参考以上示例程序中建立并发进程的方法，编写一个父子协作进程，父进程创建一个子进程并控制它每隔 3 秒显示一次当前目录中的文件名列表。</p>
<p>Exp1.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filename: exp1.c</span></span><br><span class="line"><span class="comment"> * Copyright: 2020 ALTLI </span></span><br><span class="line"><span class="comment"> * Date: 2020/04/03</span></span><br><span class="line"><span class="comment"> * Function: 父子协作进程,父进程创建一个子进程并控制它每隔 3 秒显示一次当前目录中的文件名列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exp1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> pid; <span class="comment">// 存放子进程号</span></span><br><span class="line">	<span class="type">int</span> status; <span class="comment">// 存放子进程返回状态</span></span><br><span class="line">	<span class="type">int</span> count; <span class="comment">// 记录执行次数</span></span><br><span class="line">	count = <span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">// 子进程需要执行的命令</span></span><br><span class="line">	<span class="built_in">signal</span>(SIGCONT, (<span class="type">sighandler_t</span>)sigcat); </span><br><span class="line">	</span><br><span class="line">	pid = fork(); <span class="comment">// 建立子进程</span></span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 建立子进程失败</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子进程创建失败！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 子进程执行代码段</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;我是子进程%d，我的父进程是%d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;开始执行任务：显示当前目录中文件名列表\n&quot;</span>);</span><br><span class="line">			pid = fork(); <span class="comment">// 用新创建的子进程实现exec函数，否则当前子进程中的内容会被覆盖</span></span><br><span class="line">			<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">				status = <span class="built_in">execve</span>(args[<span class="number">0</span>], args, <span class="literal">NULL</span>); <span class="comment">// 装入并执行程序</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>); <span class="comment">// 等待新创建的子进程结束</span></span><br><span class="line">				<span class="built_in">kill</span>(<span class="built_in">getppid</span>(), SIGCONT); <span class="comment">// 通知父进程继续执行</span></span><br><span class="line">				<span class="built_in">pause</span>(); <span class="comment">// 执行父进程，子进程等待父进程的开始信号</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 父进程执行代码段</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;开始第%d次执行\n&quot;</span>, count);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;我是父进程%d，接下来交给子进程%d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line">		<span class="built_in">pause</span>(); <span class="comment">// 执行子进程，等待子进程任务结束信号</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d次执行结束，休眠3秒\n&quot;</span>, count++);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;开始第%d次执行\n&quot;</span>, count);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;我是父进程%d，接下来交给子进程%d\n&quot;</span>, <span class="built_in">getpid</span>(), pid);</span><br><span class="line">			<span class="built_in">kill</span>(pid, SIGCONT); <span class="comment">// 向子进程发送开始信号</span></span><br><span class="line">			<span class="built_in">pause</span>(); <span class="comment">// 等待子进程任务结束信号</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;第%d次执行结束，休眠3秒\n&quot;</span>, count++);</span><br><span class="line">			<span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exp1.h Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXP1_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXP1_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程自定义的时间信号</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigcat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程%d收到任务结束信号\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXP1_H_INCLUDED</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Makefile Code</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ALTLI</span></span><br><span class="line"><span class="section">exp1: exp1.o</span></span><br><span class="line">	gcc exp1.o -o exp1</span><br><span class="line"></span><br><span class="line"><span class="section">exp1.o: exp1.c exp1.h</span></span><br><span class="line">	gcc -g -c exp1.c</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm exp1 *.o </span><br></pre></td></tr></table></figure>

<h3 id="结论分析"><a href="#结论分析" class="headerlink" title="结论分析"></a>结论分析</h3><p>学会使用在连接linux服务器并在上面执行文件创建、编辑、运行等操作，学会使用scp从windows本地向linux服务器传输文件。同时，加深了对于进程并发执行概念的理解。在实践中，观察和体验进程的动态特性，掌握并发进程的创建和控制方法，进一步理解进程生命期期间创建、变换、撤销状态变换的过程，了解父子进程间的控制和协作关系。</p>
<h2 id="实验二-进程通信实验"><a href="#实验二-进程通信实验" class="headerlink" title="实验二 进程通信实验"></a>实验二 进程通信实验</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>通过Linux系统中管道通信机制，加深对于进程通信概念的理解，观察和体验并发进程间的通信和协作的效果﹐练习利用无名管道进行进程通信的编程和调试技术。</p>
<h3 id="实验说明-1"><a href="#实验说明-1" class="headerlink" title="实验说明"></a>实验说明</h3><p>管道pipe是进程间通信最基本的一种机制,两个进程可以通过管道一个在管道一端向管道发送其输出,给另一进程可以在管道的另一端从管道得到其输入.管道以半双工方式工作,即它的数据流是单方向的.因此使用一个管道一般的规则是读管道数据的进程关闭管道写入端,而写管道进程关闭其读出端.</p>
<p><strong>pipe系统调用的语法为:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipe_id[<span class="number">2</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果pipe执行成功返回0, pipe_id[0]中和 pipe_id[1]将放入管道两端的描述符.出错返回-1.</p>
<h3 id="独立实验-1"><a href="#独立实验-1" class="headerlink" title="独立实验"></a>独立实验</h3><p>设有二元函数f(x,y)&#x3D; f(x)+ f(y)，其中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(x)=f(x-1)*x           (x &gt; 1)</span><br><span class="line">f(x)=1                  (x = 1)</span><br><span class="line">f(y)= f(y-1)+ f(y-2)    (y &gt; 2)</span><br><span class="line">f(y)=1                  (y = 1,2)</span><br></pre></td></tr></table></figure>


<p>请编程建立3个并发协作进程，它们分别完成f(x,y)、f(x)、f(y)</p>
<p>ppipe.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fx</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fy</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程处理f(x, Y) </span></span><br><span class="line">    <span class="type">int</span> pid1; <span class="comment">// 处理f(X)的子进程</span></span><br><span class="line">    <span class="type">int</span> pid2; <span class="comment">// 处理f(y)的子进程</span></span><br><span class="line">    <span class="type">int</span> pipe1[<span class="number">2</span>]; <span class="comment">//　pipe1处理f(x)和父进程</span></span><br><span class="line">    <span class="type">int</span> pipe2[<span class="number">2</span>]; <span class="comment">//　pipe2处理f(y)和父进程</span></span><br><span class="line">    <span class="type">int</span> x, y; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">         </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;y:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe1) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe not create\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe2) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe not create\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipe create successfully\n&quot;</span>);</span><br><span class="line">     </span><br><span class="line">    pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建立1号子进程失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;process not create\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid1 &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid2 &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 建立2号子进程失败</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process not create\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid2 &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;process create successfully\n&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid1 &gt; <span class="number">0</span> &amp;&amp; pid2 &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">close</span>(pipe1[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(pipe2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ansX, ansY;</span><br><span class="line">        <span class="built_in">read</span>(pipe1[<span class="number">0</span>], &amp;ansX, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="built_in">close</span>(pipe1[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">read</span>(pipe2[<span class="number">0</span>], &amp;ansY, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="built_in">close</span>(pipe2[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> result = ansX + ansY;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程:f(x, y) = %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 1号子进程处理f(x)</span></span><br><span class="line">    <span class="keyword">if</span> (pid1 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1号子进程只打开1号通道的写入端</span></span><br><span class="line">        <span class="built_in">close</span>(pipe1[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(pipe2[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(pipe2[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">fx</span>(x);</span><br><span class="line">        <span class="built_in">write</span>(pipe1[<span class="number">1</span>], &amp;result, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 向父进程发送结果</span></span><br><span class="line">        <span class="built_in">close</span>(pipe1[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程1:f(x)=%d\n&quot;</span>,result);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 2号子进程处理f(y)</span></span><br><span class="line">    <span class="keyword">if</span> (pid2 == <span class="number">0</span> &amp;&amp; pid1 &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ２号子进程只打开２号通道的写入端</span></span><br><span class="line">        <span class="built_in">close</span>(pipe2[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(pipe1[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(pipe1[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">fy</span>(y);</span><br><span class="line">        <span class="built_in">write</span>(pipe2[<span class="number">1</span>], &amp;result, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 向父进程发送结果</span></span><br><span class="line">        <span class="built_in">close</span>(pipe2[<span class="number">1</span>]); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程2:f(y)=%d\n&quot;</span>,result);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(x)处理函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fx</span> <span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>  x + <span class="built_in">fx</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// f(y)处理函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fy</span> <span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">1</span> || y == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fy</span>(y<span class="number">-1</span>) + <span class="built_in">fy</span>(y<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Makefile Code</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">srcs = ppipe.c </span><br><span class="line">objs = ppipe.o </span><br><span class="line">opts = -g -c </span><br><span class="line"><span class="section">all:  ppipe </span></span><br><span class="line"><span class="section">ppipe:     <span class="variable">$(objs)</span> </span></span><br><span class="line">	gcc <span class="variable">$(objs)</span>  -o ppipe </span><br><span class="line"><span class="section">ppipe.o:  <span class="variable">$(srcs)</span> </span></span><br><span class="line">	gcc <span class="variable">$(opts)</span> <span class="variable">$(srcs)</span> </span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	rm ppipe *.o</span><br></pre></td></tr></table></figure>

<h3 id="结论分析-1"><a href="#结论分析-1" class="headerlink" title="结论分析"></a>结论分析</h3><p>管道 pipe 是进程间通信最基本的一种机制,两个进程可以通过管道一个在管道一端向管道发送其输出,给另一进程可以在管道的另一端从管道得到其输入.管道以半双工方式工作,即它的数据流是单方向的.因此使用一个管道一般的规则是读管道数据的进程关闭管道写入端,而写管道进程关闭其读出端。</p>
<p>实验中需要实现一个父进程和两个子进程之间的通信，难点在于两个子进程之间的判断，然后将两个子进程分别与父进程之间建立管道进行传输。</p>
<h2 id="实验三-进程调度算法实验"><a href="#实验三-进程调度算法实验" class="headerlink" title="实验三 进程调度算法实验"></a>实验三 进程调度算法实验</h2><h3 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h3><p>加深对进程调度概念的理解，体验进程调度机制的功能，了解 Linux系统中进程调度策略的使用方法。练习进程调度算法的编程和调试技术。</p>
<h3 id="实验说明-2"><a href="#实验说明-2" class="headerlink" title="实验说明"></a>实验说明</h3><p>在 linux系统中调度策略( policy)可以是以下3种:</p>
<ul>
<li>SCHED_OTHER默认的分时调度策略(值等于O)</li>
<li>SCHED_FIFO 先进先先出调度策略(值等于1)</li>
<li>SCHED_RR时间片轮转调度策略(值等于2)</li>
</ul>
<p>后两种专用于对响应时间有特殊要求的进程，并且会抢先于SCHED_OTHER调度策略的进程而执行。一个具有SCHED_FIFO调度策略的进程只能被更高优先级的进程抢先，但具有SCHED_RR 调度策略的进程必要时可以与同级进程共享时间片。</p>
<p>进程优先数(prio)由静态优先数和动态优先数两部分组成，值越小调度优先级越高。具有SCHED_OTHER策略的进程静态优先数总是0。动态优先数与进程的执行状态有关，但可以使用nice命令或系统调用加大进程优先数使其优先级降低，或用系统调用setpriority分别按进程或进程组或用户号设置介于-20到+20之间的动态优先数。</p>
<p>与进程调度策略有关的系统调用函数原型都声明在以下文件中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>设置进程调度策略的系统调用语法为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_setscheduler</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> policy,<span class="type">const</span> <span class="keyword">struct</span> sched _param *sp)</span></span>;</span><br><span class="line">pid     进程号</span><br><span class="line">policy  以上说明的<span class="number">3</span>种调度策略之一</span><br><span class="line">sp      调度参数结构指针,调度参数结构主要存有调度优先数</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched</span> _param &#123;</span><br><span class="line">        <span class="type">int</span> sched_priority;</span><br><span class="line">    &#125;;</span><br><span class="line">返回值: 执行成功后返回<span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>获取进程调度策略的系统调用语法为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sched_getscheduler</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br><span class="line">返回值: 进程当前的调度策略</span><br></pre></td></tr></table></figure>

<p>设置进程动态优先数的系统调用语法为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpriority</span><span class="params">(<span class="type">int</span> which,<span class="type">int</span> who)</span></span>;</span><br><span class="line">which     设置的对象,可以是:</span><br><span class="line">          进程      PRIO_PROCESS</span><br><span class="line">          进程组    PRIO_PGRP</span><br><span class="line">          用户      PRIO_USER</span><br><span class="line">who       对应设置对象的进程号或组号或用户号</span><br><span class="line">返回值: 所有匹配进程中的最高优先数</span><br></pre></td></tr></table></figure>

<p>设置进程动态优先数的系统调用语法为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpriority</span><span class="params">(<span class="type">int</span> which,<span class="type">int</span> who,<span class="type">int</span> prio)</span></span>;</span><br><span class="line">which     设置的对象,可以是:</span><br><span class="line">          进程      PRIO_PROCESS</span><br><span class="line">          进程组    PRIO_PGRP</span><br><span class="line">          用户      PRIO_USER</span><br><span class="line">who       对应设置对象的进程号或组号或用户号</span><br><span class="line">prio      要设置的进程优先数</span><br><span class="line">返回值: 所有匹配进程中的最高优先数</span><br></pre></td></tr></table></figure>

<h3 id="独立实验-2"><a href="#独立实验-2" class="headerlink" title="独立实验"></a>独立实验</h3><p>设有两个并发执行的父子进程，不断循环输出各自进程号、优先数和调度策略。进程初始调度策略均为系统默认策略和默认优先级。当某个进程收到SIGINT信号时会自动将其优先数加1，收到SIGCSTP信号时会自动将其优先数减1。请编程实现以上功能。</p>
<p>psched.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// SIGINT  程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</span></span><br><span class="line"><span class="comment">// SIGTSTP  停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigcat_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;收到SIGINT信号,优先度加一\n&quot;</span>);</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>(), <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>()) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigcat_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;收到SIGTSTP信号,优先度减一\n&quot;</span>);</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>(), <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="built_in">getpid</span>()) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ctrl-C产生SIGINT信号,进程优先度加一\nCtrl-Z产生SIGCSTP信号,进程优先度减一\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(SIGINT, (<span class="type">sighandler_t</span>)sigcat_1);</span><br><span class="line">        <span class="built_in">signal</span>(SIGTSTP, (<span class="type">sighandler_t</span>)sigcat_2);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==============\n子进程 PID = %d \n优先级= %d \n调度策略= %d\n==============\n\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="number">0</span>), <span class="built_in">sched_getscheduler</span>(<span class="built_in">getpid</span>()));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(SIGINT, (<span class="type">sighandler_t</span>)sigcat_1);</span><br><span class="line">        <span class="built_in">signal</span>(SIGTSTP, (<span class="type">sighandler_t</span>)sigcat_2);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==============\n父进程 PID = %d \n优先级= %d \n调度策略= %d\n==============\n\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getpriority</span>(PRIO_PROCESS, <span class="number">0</span>), <span class="built_in">sched_getscheduler</span>(<span class="built_in">getpid</span>()));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Makefile</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">srcs = psched.c </span><br><span class="line">objs = psched.o </span><br><span class="line">opts = -g -c </span><br><span class="line">all: 	psched </span><br><span class="line">psched: 	$(objs) </span><br><span class="line">	gcc $(objs) -o psched </span><br><span class="line">psched.o: 	$(srcs) </span><br><span class="line">		gcc $(opts) $(srcs) </span><br><span class="line">clean: </span><br><span class="line">	rm psched *.o</span><br></pre></td></tr></table></figure>

<h3 id="结论分析-2"><a href="#结论分析-2" class="headerlink" title="结论分析"></a>结论分析</h3><p>进程优先数(prio)由静态优先数和动态优先数两部分组成，值越小调度优先级越高。具有SCHED_OTHER策略的进程静态优先数总是0。动态优先数与进程的执行状态有关，但可以使用nice命令或系统调用加大进程优先数使其优先级降低，或用系统调用setpriority分别按进程或进程组或用户号设置介于-20到+20之间的动态优先数。通过ctrl+c输入sigint信号，ctrl+z输入sigtstp信号，控制进程优先级的改变。</p>
<h2 id="实验四-进程同步实验"><a href="#实验四-进程同步实验" class="headerlink" title="实验四 进程同步实验"></a>实验四 进程同步实验</h2><h3 id="实验目的-3"><a href="#实验目的-3" class="headerlink" title="实验目的"></a>实验目的</h3><p>加深对并发协作进程同步与互斥概念的理解，观察和体验并发进程同步与互斥操作的效果，分析与研究经典进程同步与互斥问题的实际解决方案。了解 Linux系统中IPC进程同步工具的用法，练习并发协作进程的同步与互斥操作的编程与调试技术。</p>
<h3 id="实验说明-3"><a href="#实验说明-3" class="headerlink" title="实验说明"></a>实验说明</h3><p>在linux系统中可以利用进程间通信( interprocess communication )IPC中的3个对象:共享内存、信号灯数组、消息队列，来解决协作并发进程间的同步与互斥的问题。</p>
<h3 id="独立实验-3"><a href="#独立实验-3" class="headerlink" title="独立实验"></a>独立实验</h3><p>ipc.h Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ipc.h</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Function: 声明 IPC 机制的函数原型和全局变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IPC_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPC_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSZ 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立或获取 ipc 的一组函数的原型说明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ipc_id</span><span class="params">(<span class="type">char</span> *proc_file,<span class="type">key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">set_shm</span><span class="params">(<span class="type">key_t</span> shm_key,<span class="type">int</span> shm_num,<span class="type">int</span> shm_flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_msq</span><span class="params">(<span class="type">key_t</span> msq_key,<span class="type">int</span> msq_flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_sem</span><span class="params">(<span class="type">key_t</span> sem_key,<span class="type">int</span> sem_val,<span class="type">int</span> sem_flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> sem_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> sem_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号灯控制用的共同体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">semuns</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125; Sem_uns;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消息结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msgbuf</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> mtype;</span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125; Msg_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产消费者共享缓冲区即其有关的变量</span></span><br><span class="line"><span class="type">key_t</span> buff_key;</span><br><span class="line"><span class="type">int</span> buff_num;</span><br><span class="line"><span class="type">char</span> *buff_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者放产品位置的共享指针</span></span><br><span class="line"><span class="type">key_t</span> pput_key;</span><br><span class="line"><span class="type">int</span> pput_num;</span><br><span class="line"><span class="type">int</span> *pput_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前材料的共享指针</span></span><br><span class="line"><span class="type">key_t</span> mat_key;</span><br><span class="line"><span class="type">int</span> mat_num;</span><br><span class="line"><span class="type">int</span> *mat_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者取产品位置的共享指针</span></span><br><span class="line"><span class="type">key_t</span> cget_key;</span><br><span class="line"><span class="type">int</span> cget_num;</span><br><span class="line"><span class="type">int</span> *cget_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者有关的信号量</span></span><br><span class="line"><span class="type">key_t</span> prod_key;</span><br><span class="line"><span class="type">key_t</span> pmtx_key;</span><br><span class="line"><span class="type">int</span> prod_sem;</span><br><span class="line"><span class="type">int</span> pmtx_sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者有关的信号量</span></span><br><span class="line"><span class="type">key_t</span> cons_key;</span><br><span class="line"><span class="type">key_t</span> cmtx_key;</span><br><span class="line"><span class="type">int</span> cons_sem;</span><br><span class="line"><span class="type">int</span> cmtx_sem;</span><br><span class="line"><span class="type">int</span> sem_val;</span><br><span class="line"><span class="type">int</span> sem_flg;</span><br><span class="line"><span class="type">int</span> shm_flg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// IPC_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>

<p>ipc.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ipc.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Data: 2020/4/10</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_ipc_id() 从/proc/sysvipc/文件系统中获取 IPC 的 id 号 </span></span><br><span class="line"><span class="comment"> * pfile: 对应/proc/sysvipc/目录中的 IPC 文件分别为</span></span><br><span class="line"><span class="comment"> * msg-消息队列,sem-信号量,shm-共享内存</span></span><br><span class="line"><span class="comment"> * key: 对应要获取的 IPC 的 id 号的键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ipc_id</span><span class="params">(<span class="type">char</span> *proc_file, <span class="type">key_t</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *pf;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">char</span> line[BUFSZ], colum[BUFSZ];</span><br><span class="line">	<span class="keyword">if</span>((pf = <span class="built_in">fopen</span>(proc_file, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;Proc file not open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fgets</span>(line, BUFSZ, pf);</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))</span><br><span class="line">	&#123;</span><br><span class="line">		i = j = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fgets</span>(line, BUFSZ, pf);</span><br><span class="line">		<span class="keyword">while</span>(line[i] == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">while</span>(line[i] != <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">			colum[j++] = line[i++];</span><br><span class="line">		colum[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">atoi</span>(colum) != key) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(line[i] == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">while</span>(line[i] !=<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">			colum[j++] = line[i++];</span><br><span class="line">		colum[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		i = <span class="built_in">atoi</span>(colum);</span><br><span class="line">		<span class="built_in">fclose</span>(pf);</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(pf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 信号灯上的 down/up 操作</span></span><br><span class="line"><span class="comment"> * semid:信号灯数组标识符</span></span><br><span class="line"><span class="comment"> * semnum:信号灯数组下标</span></span><br><span class="line"><span class="comment"> * buf:操作信号灯的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sembuf</span> buf;</span><br><span class="line">	buf.sem_op = <span class="number">-1</span>;</span><br><span class="line">	buf.sem_num = <span class="number">0</span>;</span><br><span class="line">	buf.sem_flg = SEM_UNDO;</span><br><span class="line">	<span class="keyword">if</span>((<span class="built_in">semop</span>(sem_id, &amp;buf, <span class="number">1</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;down error &quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sembuf</span> buf;</span><br><span class="line">	buf.sem_op = <span class="number">1</span>;</span><br><span class="line">	buf.sem_num = <span class="number">0</span>;</span><br><span class="line">	buf.sem_flg = SEM_UNDO;</span><br><span class="line">	<span class="keyword">if</span>((<span class="built_in">semop</span>(sem_id, &amp;buf, <span class="number">1</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;up error &quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_sem 函数建立一个具有 n 个信号灯的信号量</span></span><br><span class="line"><span class="comment"> * 如果建立成功,返回 一个信号灯数组的标识符 sem_id</span></span><br><span class="line"><span class="comment"> * 输入参数:</span></span><br><span class="line"><span class="comment"> * sem_key 信号灯数组的键值</span></span><br><span class="line"><span class="comment"> * sem_val 信号灯数组中信号灯的个数</span></span><br><span class="line"><span class="comment"> * sem_flag 信号等数组的存取权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_sem</span><span class="params">(<span class="type">key_t</span> sem_key,<span class="type">int</span> sem_val,<span class="type">int</span> sem_flg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sem_id;</span><br><span class="line">	Sem_uns sem_arg;</span><br><span class="line">	<span class="comment">// 测试由 sem_key 标识的信号灯数组是否已经建立</span></span><br><span class="line">	<span class="keyword">if</span>((sem_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/sem&quot;</span>, sem_key)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// semget 新建一个信号灯,其标号返回到 sem_id</span></span><br><span class="line">		<span class="keyword">if</span>((sem_id = <span class="built_in">semget</span>(sem_key, <span class="number">1</span>, sem_flg)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;semaphore create error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置信号灯的初值</span></span><br><span class="line">		sem_arg.val = sem_val;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_arg) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;semaphore set error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_shm 函数建立一个具有 n 个字节 的共享内存区</span></span><br><span class="line"><span class="comment"> * 如果建立成功,返回一个指向该内存区首地址的指针 shm_buf</span></span><br><span class="line"><span class="comment"> * 输入参数:</span></span><br><span class="line"><span class="comment"> * shm_key 共享内存的键值</span></span><br><span class="line"><span class="comment"> * shm_val 共享内存字节的长度</span></span><br><span class="line"><span class="comment"> * shm_flag 共享内存的存取权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">set_shm</span><span class="params">(<span class="type">key_t</span> shm_key,<span class="type">int</span> shm_num,<span class="type">int</span> shm_flg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, shm_id;</span><br><span class="line">	<span class="type">char</span> * shm_buf;</span><br><span class="line">	<span class="comment">// 测试由 shm_key 标识的共享内存区是否已经建立</span></span><br><span class="line">	<span class="keyword">if</span>((shm_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/shm&quot;</span>, shm_key)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// shmget 新建 一个长度为 shm_num 字节的共享内存,其标号返回到 shm_id</span></span><br><span class="line">		<span class="keyword">if</span>((shm_id = <span class="built_in">shmget</span>(shm_key,shm_num,shm_flg)) &lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;shareMemory set error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// shmat 将由 shm_id 标识的共享内存附加给指针 shm_buf</span></span><br><span class="line">		<span class="keyword">if</span>((shm_buf = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shm_id,<span class="number">0</span>,<span class="number">0</span>)) &lt; (<span class="type">char</span> *)<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;get shareMemory error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; shm_num; i++) </span><br><span class="line">			shm_buf[i] = <span class="number">0</span>; <span class="comment">//初始为 0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// shm_key 标识的共享内存区已经建立,将由 shm_id 标识的共享内存附加给指针 shm_buf</span></span><br><span class="line">	<span class="keyword">if</span>((shm_buf = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shm_id,<span class="number">0</span>,<span class="number">0</span>)) &lt; (<span class="type">char</span> *)<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;get shareMemory error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shm_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * set_msq 函数建立一个消息队列</span></span><br><span class="line"><span class="comment"> * 如果建立成功,返回 一个消息队列的标识符 msq_id</span></span><br><span class="line"><span class="comment"> * 输入参数:</span></span><br><span class="line"><span class="comment"> * msq_key 消息队列的键值</span></span><br><span class="line"><span class="comment"> * msq_flag 消息队列的存取权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_msq</span><span class="params">(<span class="type">key_t</span> msq_key,<span class="type">int</span> msq_flg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> msq_id;</span><br><span class="line">	<span class="comment">//测试由 msq_key 标识的消息队列是否已经建立</span></span><br><span class="line">	<span class="keyword">if</span>((msq_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/msg&quot;</span>, msq_key)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//msgget 新建一个消息队列,其标号返回到 msq_id</span></span><br><span class="line">		<span class="keyword">if</span>((msq_id = <span class="built_in">msgget</span>(msq_key,msq_flg)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;messageQueue set error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msq_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer_glue.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * consumer_tobacco.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Function: 有胶水的抽烟者的消费者进程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_material_name</span><span class="params">(<span class="type">char</span> c)</span></span>; <span class="comment">// 获取材料的名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 三种材料，分别代表：T烟草、P纸、G胶水</span></span><br><span class="line">	<span class="type">char</span> material[<span class="number">3</span>] = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">	<span class="type">char</span>* material_name[<span class="number">3</span>] = &#123;<span class="string">&quot;烟草&quot;</span>, <span class="string">&quot;纸张&quot;</span>, <span class="string">&quot;胶水&quot;</span>&#125;;</span><br><span class="line">	<span class="type">int</span> rate;</span><br><span class="line">	<span class="comment">// 可在在命令行第一参数指定一个进程睡眠秒数,以调解进程执行速度</span></span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] != <span class="literal">NULL</span>) </span><br><span class="line">		rate = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		rate = <span class="number">3</span>; <span class="comment">// 不指定为 3 秒</span></span><br><span class="line">	<span class="comment">// 共享内存 使用的变量</span></span><br><span class="line">	buff_key = <span class="number">1001</span>; <span class="comment">// 缓冲区任给的键值</span></span><br><span class="line">	buff_num = <span class="number">2</span>; <span class="comment">// 缓冲区任给的长度</span></span><br><span class="line">	cget_key = <span class="number">1003</span>; <span class="comment">// 消费者取产品指针的键值</span></span><br><span class="line">	cget_num = <span class="number">1</span>; <span class="comment">// 指针数</span></span><br><span class="line">	shm_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">//共享内存读写权限</span></span><br><span class="line">	<span class="comment">// 获取缓冲区使用的共享内存,buff_ptr 指向缓冲区首地址</span></span><br><span class="line">	buff_ptr = (<span class="type">char</span> *)<span class="built_in">set_shm</span>(buff_key,buff_num,shm_flg);</span><br><span class="line">	<span class="comment">// 获取消费者取产品指针,cget_ptr 指向索引地址</span></span><br><span class="line">	cget_ptr = (<span class="type">int</span> *)<span class="built_in">set_shm</span>(cget_key,cget_num,shm_flg);</span><br><span class="line">	<span class="comment">// 信号量使用的变量</span></span><br><span class="line">	prod_key = <span class="number">2001</span>; <span class="comment">// 生产者同步信号灯键值</span></span><br><span class="line">	pmtx_key = <span class="number">2002</span>; <span class="comment">// 生产者互斥信号灯键值</span></span><br><span class="line">	cons_key = <span class="number">3001</span>; <span class="comment">// 消费者同步信号灯键值</span></span><br><span class="line">	cmtx_key = <span class="number">3002</span>; <span class="comment">// 消费者互斥信号灯键值</span></span><br><span class="line">	sem_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">// 信号灯操作权限</span></span><br><span class="line">	<span class="comment">// 生产者同步信号灯初值设为缓冲区最大可用量</span></span><br><span class="line">	sem_val = buff_num;</span><br><span class="line">	<span class="comment">// 获取生产者同步信号灯,引用标识存 prod_sem</span></span><br><span class="line">	prod_sem = <span class="built_in">set_sem</span>(prod_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 消费者初始无产品可取,同步信号灯初值设为 0</span></span><br><span class="line">	sem_val = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 获取消费者同步信号灯,引用标识存 cons_sem</span></span><br><span class="line">	cons_sem = <span class="built_in">set_sem</span>(cons_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 消费者互斥信号灯初值为 1</span></span><br><span class="line">	sem_val = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 获取消费者互斥信号灯,引用标识存 pmtx_sem</span></span><br><span class="line">	cmtx_sem = <span class="built_in">set_sem</span>(cmtx_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 循环执行模拟消费者不断取产品</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果无产品消费者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(cons_sem);</span><br><span class="line">		<span class="comment">// 如果另一消费者正在取产品,本消费者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(cmtx_sem);</span><br><span class="line">		<span class="comment">// 用读一字符的形式模拟消费者取产品,报告本进程号和获取的字符及读取的位置</span></span><br><span class="line">		<span class="comment">// 判断当前拥有的材料能否卷烟，如果提供的材料与烟草不同，说明可以吸烟</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (buff_ptr[i] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 该抽烟者无法卷烟，唤醒阻塞的其他抽烟者</span></span><br><span class="line">			<span class="built_in">up</span>(cons_sem);</span><br><span class="line">			<span class="built_in">up</span>(cmtx_sem);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep</span>(rate);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d 抽烟者（胶水）得到: %s from Buffer[%d]\n&quot;</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">				material_name[<span class="built_in">get_material_name</span>(buff_ptr[*cget_ptr])], *cget_ptr);</span><br><span class="line">				<span class="comment">// 读取位置循环下移</span></span><br><span class="line">				*cget_ptr = (*cget_ptr+<span class="number">1</span>) % buff_num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 唤醒阻塞的其他抽烟者</span></span><br><span class="line">			<span class="built_in">up</span>(cmtx_sem);</span><br><span class="line">			<span class="comment">// 唤醒阻塞的第一个生产者</span></span><br><span class="line">			<span class="built_in">up</span>(prod_sem);</span><br><span class="line">			<span class="comment">// 唤醒阻塞的第二个生产者</span></span><br><span class="line">			<span class="built_in">up</span>(prod_sem);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_material_name</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer_paper.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * consumer_tobacco.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Function: 有纸的抽烟者的消费者进程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_material_name</span><span class="params">(<span class="type">char</span> c)</span></span>; <span class="comment">// 获取材料的名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 三种材料，分别代表：T烟草、P纸、G胶水</span></span><br><span class="line">	<span class="type">char</span> material[<span class="number">3</span>] = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">	<span class="type">char</span>* material_name[<span class="number">3</span>] = &#123;<span class="string">&quot;烟草&quot;</span>, <span class="string">&quot;纸张&quot;</span>, <span class="string">&quot;胶水&quot;</span>&#125;;</span><br><span class="line">	<span class="type">int</span> rate;</span><br><span class="line">	<span class="comment">// 可在在命令行第一参数指定一个进程睡眠秒数,以调解进程执行速度</span></span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] != <span class="literal">NULL</span>) </span><br><span class="line">		rate = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		rate = <span class="number">3</span>; <span class="comment">// 不指定为 3 秒</span></span><br><span class="line">	<span class="comment">// 共享内存 使用的变量</span></span><br><span class="line">	buff_key = <span class="number">1001</span>; <span class="comment">// 缓冲区任给的键值</span></span><br><span class="line">	buff_num = <span class="number">2</span>; <span class="comment">// 缓冲区任给的长度</span></span><br><span class="line">	cget_key = <span class="number">1003</span>; <span class="comment">// 消费者取产品指针的键值</span></span><br><span class="line">	cget_num = <span class="number">1</span>; <span class="comment">// 指针数</span></span><br><span class="line">	shm_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">//共享内存读写权限</span></span><br><span class="line">	<span class="comment">// 获取缓冲区使用的共享内存,buff_ptr 指向缓冲区首地址</span></span><br><span class="line">	buff_ptr = (<span class="type">char</span> *)<span class="built_in">set_shm</span>(buff_key,buff_num,shm_flg);</span><br><span class="line">	<span class="comment">// 获取消费者取产品指针,cget_ptr 指向索引地址</span></span><br><span class="line">	cget_ptr = (<span class="type">int</span> *)<span class="built_in">set_shm</span>(cget_key,cget_num,shm_flg);</span><br><span class="line">	<span class="comment">// 信号量使用的变量</span></span><br><span class="line">	prod_key = <span class="number">2001</span>; <span class="comment">// 生产者同步信号灯键值</span></span><br><span class="line">	pmtx_key = <span class="number">2002</span>; <span class="comment">// 生产者互斥信号灯键值</span></span><br><span class="line">	cons_key = <span class="number">3001</span>; <span class="comment">// 消费者同步信号灯键值</span></span><br><span class="line">	cmtx_key = <span class="number">3002</span>; <span class="comment">// 消费者互斥信号灯键值</span></span><br><span class="line">	sem_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">// 信号灯操作权限</span></span><br><span class="line">	<span class="comment">// 生产者同步信号灯初值设为缓冲区最大可用量</span></span><br><span class="line">	sem_val = buff_num;</span><br><span class="line">	<span class="comment">// 获取生产者同步信号灯,引用标识存 prod_sem</span></span><br><span class="line">	prod_sem = <span class="built_in">set_sem</span>(prod_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 消费者初始无产品可取,同步信号灯初值设为 0</span></span><br><span class="line">	sem_val = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 获取消费者同步信号灯,引用标识存 cons_sem</span></span><br><span class="line">	cons_sem = <span class="built_in">set_sem</span>(cons_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 消费者互斥信号灯初值为 1</span></span><br><span class="line">	sem_val = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 获取消费者互斥信号灯,引用标识存 pmtx_sem</span></span><br><span class="line">	cmtx_sem = <span class="built_in">set_sem</span>(cmtx_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 循环执行模拟消费者不断取产品</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果无产品消费者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(cons_sem);</span><br><span class="line">		<span class="comment">// 如果另一消费者正在取产品,本消费者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(cmtx_sem);</span><br><span class="line">		<span class="comment">// 用读一字符的形式模拟消费者取产品,报告本进程号和获取的字符及读取的位置</span></span><br><span class="line">		<span class="comment">// 判断当前拥有的材料能否卷烟，如果提供的材料与烟草不同，说明可以吸烟</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (buff_ptr[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 该抽烟者无法卷烟，唤醒阻塞的其他抽烟者</span></span><br><span class="line">			<span class="built_in">up</span>(cons_sem);</span><br><span class="line">			<span class="built_in">up</span>(cmtx_sem);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep</span>(rate);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d 抽烟者（纸）得到: %s from Buffer[%d]\n&quot;</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">				material_name[<span class="built_in">get_material_name</span>(buff_ptr[*cget_ptr])], *cget_ptr);</span><br><span class="line">				<span class="comment">// 读取位置循环下移</span></span><br><span class="line">				*cget_ptr = (*cget_ptr+<span class="number">1</span>) % buff_num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 唤醒阻塞的其他抽烟者</span></span><br><span class="line">			<span class="built_in">up</span>(cmtx_sem);</span><br><span class="line">			<span class="comment">// 唤醒阻塞的第一个生产者</span></span><br><span class="line">			<span class="built_in">up</span>(prod_sem);</span><br><span class="line">			<span class="comment">// 唤醒阻塞的第二个生产者</span></span><br><span class="line">			<span class="built_in">up</span>(prod_sem);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_material_name</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer_tobacco.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * consumer_tobacco.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Function: 有烟草的抽烟者的消费者进程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_material_name</span><span class="params">(<span class="type">char</span> c)</span></span>; <span class="comment">// 获取材料的名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 三种材料，分别代表：T烟草、P纸、G胶水</span></span><br><span class="line">	<span class="type">char</span> material[<span class="number">3</span>] = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">	<span class="type">char</span>* material_name[<span class="number">3</span>] = &#123;<span class="string">&quot;烟草&quot;</span>, <span class="string">&quot;纸张&quot;</span>, <span class="string">&quot;胶水&quot;</span>&#125;;</span><br><span class="line">	<span class="type">int</span> rate;</span><br><span class="line">	<span class="comment">// 可在在命令行第一参数指定一个进程睡眠秒数,以调解进程执行速度</span></span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] != <span class="literal">NULL</span>) </span><br><span class="line">		rate = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		rate = <span class="number">3</span>; <span class="comment">// 不指定为 3 秒</span></span><br><span class="line">	<span class="comment">// 共享内存 使用的变量</span></span><br><span class="line">	buff_key = <span class="number">1001</span>; <span class="comment">// 缓冲区任给的键值</span></span><br><span class="line">	buff_num = <span class="number">2</span>; <span class="comment">// 缓冲区任给的长度</span></span><br><span class="line">	cget_key = <span class="number">1003</span>; <span class="comment">// 消费者取产品指针的键值</span></span><br><span class="line">	cget_num = <span class="number">1</span>; <span class="comment">// 指针数</span></span><br><span class="line">	shm_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">//共享内存读写权限</span></span><br><span class="line">	<span class="comment">// 获取缓冲区使用的共享内存,buff_ptr 指向缓冲区首地址</span></span><br><span class="line">	buff_ptr = (<span class="type">char</span> *)<span class="built_in">set_shm</span>(buff_key,buff_num,shm_flg);</span><br><span class="line">	<span class="comment">// 获取消费者取产品指针,cget_ptr 指向索引地址</span></span><br><span class="line">	cget_ptr = (<span class="type">int</span> *)<span class="built_in">set_shm</span>(cget_key,cget_num,shm_flg);</span><br><span class="line">	<span class="comment">// 信号量使用的变量</span></span><br><span class="line">	prod_key = <span class="number">2001</span>; <span class="comment">// 生产者同步信号灯键值</span></span><br><span class="line">	pmtx_key = <span class="number">2002</span>; <span class="comment">// 生产者互斥信号灯键值</span></span><br><span class="line">	cons_key = <span class="number">3001</span>; <span class="comment">// 消费者同步信号灯键值</span></span><br><span class="line">	cmtx_key = <span class="number">3002</span>; <span class="comment">// 消费者互斥信号灯键值</span></span><br><span class="line">	sem_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">// 信号灯操作权限</span></span><br><span class="line">	<span class="comment">// 生产者同步信号灯初值设为缓冲区最大可用量</span></span><br><span class="line">	sem_val = buff_num;</span><br><span class="line">	<span class="comment">// 获取生产者同步信号灯,引用标识存 prod_sem</span></span><br><span class="line">	prod_sem = <span class="built_in">set_sem</span>(prod_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 消费者初始无产品可取,同步信号灯初值设为 0</span></span><br><span class="line">	sem_val = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 获取消费者同步信号灯,引用标识存 cons_sem</span></span><br><span class="line">	cons_sem = <span class="built_in">set_sem</span>(cons_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 消费者互斥信号灯初值为 1</span></span><br><span class="line">	sem_val = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 获取消费者互斥信号灯,引用标识存 pmtx_sem</span></span><br><span class="line">	cmtx_sem = <span class="built_in">set_sem</span>(cmtx_key,sem_val,sem_flg);</span><br><span class="line">	<span class="comment">// 循环执行模拟消费者不断取产品</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果无产品消费者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(cons_sem);</span><br><span class="line">		<span class="comment">// 如果另一消费者正在取产品,本消费者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(cmtx_sem);</span><br><span class="line">		<span class="comment">// 用读一字符的形式模拟消费者取产品,报告本进程号和获取的字符及读取的位置</span></span><br><span class="line">		<span class="comment">// 判断当前拥有的材料能否卷烟，如果提供的材料与烟草不同，说明可以吸烟</span></span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (buff_ptr[i] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 该抽烟者无法卷烟，唤醒阻塞的其他抽烟者</span></span><br><span class="line">			<span class="built_in">up</span>(cons_sem);</span><br><span class="line">			<span class="built_in">up</span>(cmtx_sem);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sleep</span>(rate);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d 抽烟者（烟草）得到: %s from Buffer[%d]\n&quot;</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">				material_name[<span class="built_in">get_material_name</span>(buff_ptr[*cget_ptr])], *cget_ptr);</span><br><span class="line">				<span class="comment">// 读取位置循环下移</span></span><br><span class="line">				*cget_ptr = (*cget_ptr+<span class="number">1</span>) % buff_num;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 唤醒阻塞的其他抽烟者</span></span><br><span class="line">			<span class="built_in">up</span>(cmtx_sem);</span><br><span class="line">			<span class="comment">// 唤醒阻塞的第一个生产者</span></span><br><span class="line">			<span class="built_in">up</span>(prod_sem);</span><br><span class="line">			<span class="comment">// 唤醒阻塞的第二个生产者</span></span><br><span class="line">			<span class="built_in">up</span>(prod_sem);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_material_name</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: </span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>producer.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * producer.c</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Function: 建立并模拟生产者进程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 三种材料，分别代表：T烟草、P纸、G胶水</span></span><br><span class="line">	<span class="type">char</span> material[<span class="number">3</span>] = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">	<span class="type">int</span> rate;</span><br><span class="line">	<span class="comment">// 可在在命令行第一参数指定一个进程睡眠秒数,以调解进程执行速度</span></span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] != <span class="literal">NULL</span>) </span><br><span class="line">		rate = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		rate = <span class="number">3</span>; <span class="comment">// 不指定则为 3 秒</span></span><br><span class="line">	<span class="comment">// 共享内存使用的变量</span></span><br><span class="line">	buff_key = <span class="number">1001</span>; <span class="comment">// 缓冲区任给的键值</span></span><br><span class="line">	buff_num = <span class="number">2</span>; <span class="comment">// 缓冲区长度，两个材料</span></span><br><span class="line">	pput_key = <span class="number">1002</span>; <span class="comment">// 生产者放产品指针的键值</span></span><br><span class="line">	pput_num = <span class="number">1</span>; <span class="comment">// 指针数</span></span><br><span class="line">	mat_key = <span class="number">1004</span>; <span class="comment">// 当前材料的键值</span></span><br><span class="line">	mat_num = <span class="number">1</span>; <span class="comment">//　指针数</span></span><br><span class="line">	shm_flg = IPC_CREAT | <span class="number">0644</span>; <span class="comment">// 共享内存读写权限</span></span><br><span class="line">	<span class="comment">// 获取缓冲区使用的共享内存,buff_ptr 指向缓冲区首地址</span></span><br><span class="line">	buff_ptr = (<span class="type">char</span>*)<span class="built_in">set_shm</span>(buff_key, buff_num, shm_flg);</span><br><span class="line">	<span class="comment">// 获取生产者放产品位置指针 pput_ptr</span></span><br><span class="line">	pput_ptr = (<span class="type">int</span>*)<span class="built_in">set_shm</span>(pput_key, pput_num, shm_flg);</span><br><span class="line">	<span class="comment">// 获取当前材料指针　mat_ptr</span></span><br><span class="line">	mat_ptr = (<span class="type">int</span>*)<span class="built_in">set_shm</span>(mat_key, mat_num, shm_flg);</span><br><span class="line">	<span class="comment">// 信号量使用的变量</span></span><br><span class="line">	prod_key = <span class="number">2001</span>; <span class="comment">// 生产者同步信号灯键值</span></span><br><span class="line">	pmtx_key = <span class="number">2002</span>; <span class="comment">// 生产者互斥信号灯键值</span></span><br><span class="line">	cons_key = <span class="number">3001</span>; <span class="comment">// 消费者同步信号灯键值</span></span><br><span class="line">	cmtx_key = <span class="number">3002</span>; <span class="comment">// 消费者互斥信号灯键值</span></span><br><span class="line">	sem_flg = IPC_CREAT | <span class="number">0644</span>;</span><br><span class="line">	<span class="comment">// 生产者同步信号灯初值设为缓冲区最大可用量</span></span><br><span class="line">	sem_val = buff_num;</span><br><span class="line">	<span class="comment">// 获取生产者同步信号灯,引用标识存 prod_sem</span></span><br><span class="line">	prod_sem = <span class="built_in">set_sem</span>(prod_key, sem_val, sem_flg);</span><br><span class="line">	<span class="comment">// 消费者初始无产品可取,同步信号灯初值设为 0</span></span><br><span class="line">	sem_val = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 获取消费者同步信号灯,引用标识存 cons_sem</span></span><br><span class="line">	cons_sem = <span class="built_in">set_sem</span>(cons_key, sem_val, sem_flg);</span><br><span class="line">	<span class="comment">// 生产者互斥信号灯初值为 1</span></span><br><span class="line">	sem_val = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 获取生产者互斥信号灯,引用标识存 pmtx_sem</span></span><br><span class="line">	pmtx_sem = <span class="built_in">set_sem</span>(pmtx_key, sem_val, sem_flg);</span><br><span class="line">	<span class="comment">// 循环执行模拟生产者不断放产品</span></span><br><span class="line">	<span class="comment">//int count = 1;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果缓冲区满则生产者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(prod_sem);</span><br><span class="line">		<span class="comment">// 如果另一生产者正在放产品,本生产者阻塞</span></span><br><span class="line">		<span class="built_in">down</span>(pmtx_sem);</span><br><span class="line">		<span class="comment">// 用写一字符的形式模拟生产者放产品,报告本进程号和放入的字符及存放的位置</span></span><br><span class="line">		</span><br><span class="line">		buff_ptr[*pput_ptr] = material[*mat_ptr];</span><br><span class="line">		<span class="built_in">sleep</span>(rate);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d producer put: %c to Buffer[%d]\n&quot;</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">		buff_ptr[*pput_ptr], *pput_ptr);</span><br><span class="line">		<span class="comment">// 存放位置循环下移</span></span><br><span class="line">		<span class="comment">//printf(&quot;%d\n&quot;, count++);</span></span><br><span class="line">		*pput_ptr = (*pput_ptr+<span class="number">1</span>) % buff_num;</span><br><span class="line">		*mat_ptr = (*mat_ptr+<span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 唤醒阻塞的生产者</span></span><br><span class="line">		<span class="built_in">up</span>(pmtx_sem);</span><br><span class="line">		<span class="keyword">if</span> (*pput_ptr == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 在放置完两个材料后，唤醒阻塞的消费者</span></span><br><span class="line">			<span class="built_in">up</span>(cons_sem);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结论分析-3"><a href="#结论分析-3" class="headerlink" title="结论分析"></a>结论分析</h3><p>通过创建一个生产者循环生成三种材料，每个材料都单独用single来控制生产，保证每次都产生两种要求的材料并存在公共区给吸烟者，通过上次的管道实验，这次加深了对通信的理解。</p>
<h2 id="实验五-进程互斥实验"><a href="#实验五-进程互斥实验" class="headerlink" title="实验五 进程互斥实验"></a>实验五 进程互斥实验</h2><h3 id="实验目的-4"><a href="#实验目的-4" class="headerlink" title="实验目的"></a>实验目的</h3><p>进一步研究和实践操作系统中关于并发进程同步与互斥操作的一些经典问题的解法，加深对于非对称性互斥问题有关概念的理解。观察和体验非对称性互斥问题的并发控制方法。进一步了解Linux系统中IPC进程同步工具的用法，训练解决对该类问题的实际编程、调试和分析问题的能力。</p>
<h3 id="实验说明-4"><a href="#实验说明-4" class="headerlink" title="实验说明"></a>实验说明</h3><p>以下示例实验程序应能模拟一个读者&#x2F;写者问题,它应能实现一下功能:</p>
<ul>
<li>任意多个读者可以同时读;</li>
<li>任意时刻只能有一个写者写;</li>
<li>如果写者正在写，那么读者就必须等待;</li>
<li>如果读者正在读，那么写者也必须等待;</li>
<li>允许写者优先;</li>
<li>防止读者或写者发生饥饿。</li>
</ul>
<p>为了能够体验IPC机制的消息队列的用法，本示例程序采用了Theaker &amp;Brookes提出的消息传递算法。该算法中有一控制进程，带有3个不同类型的消息信箱，它们分别是:读请求信箱、写请求信箱和操作完成信箱。读者需要访问临界资源时首先要向控制进程发送读请求消息，写者需要访问临界资源时也要先向控制进程发送写请求消息，在得到控制进程的允许消息后方可进入临界区读或写。读或写者在完成对临界资源的访问后还要向控制进程发送操作完成消息。控制进程使用一个变量count 控制读写者互斥的访问临界资源并允许写者优先。count的初值需要一个比最大读者数还要大的数，本例取值为100。当count大于0时说明没有新的读写请求，控制进程接收读写者新的请求，如果收到读者完成消息，对count 的值加1，如果收到写者请求消息，count的值减100，如果收到读者请求消息，对count的值减1。当count等于0时说明写者正在写，控制进程等待写者完成后再次令count的值等于100。当count小于0时说明读者正在读，控制进程等待读者完成后对count的值加1。</p>
<h3 id="独立实验-4"><a href="#独立实验-4" class="headerlink" title="独立实验"></a>独立实验</h3><p>理发店问题:假设理发店的理发室中有3个理发椅子和3个理发师，有一个可容纳4个顾客坐等理发的沙发。此外还有一间等候室，可容纳13位顾客等候进入理发室。顾客如果发现理发店中顾客已满（超过20人），就不进入理发店。</p>
<p>在理发店内，理发师一旦有空就为坐在沙发上等待时间最长的顾客理发，同时空出的沙发让在等候室中等待时间最长的的顾客就坐。顾客理完发后，可向任何一位理发师付款。但理发店只有一本现金登记册，在任一时刻只能记录一个顾客的付款。理发师在没有顾客的时候就坐在理发椅子上睡眠。理发师的时间就用在理发、收款、睡眠上。</p>
<p>请利用linux系统提供的IPC进程通信机制实验并实现理发店问题的一个解法。</p>
<p>ipc.h Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSZ 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVAL 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRSIZ 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITERQUEST 1 <span class="comment">//写请求标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READERQUEST 2 <span class="comment">//读请求标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FINISHED 3 <span class="comment">//读写完成标识</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFA 4<span class="comment">//沙发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT 5<span class="comment">//等候室</span></span></span><br><span class="line"><span class="comment">/*信号灯控制用的共同体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">semuns</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125; Sem_uns;</span><br><span class="line"><span class="comment">/* 消息结构体*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">msgbuf</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">&#125; Msg_buf;</span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> buff_key;</span><br><span class="line"><span class="type">int</span> buff_num;</span><br><span class="line"><span class="type">char</span> *buff_ptr;</span><br><span class="line"><span class="type">int</span> shm_flg;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> quest_flg;</span><br><span class="line"><span class="type">key_t</span> quest_key;</span><br><span class="line"><span class="type">int</span> quest_id;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> respond_flg;</span><br><span class="line"><span class="type">key_t</span> respond_key;</span><br><span class="line"><span class="type">int</span> respond_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ipc_id</span> <span class="params">(<span class="type">char</span> *proc_file, <span class="type">key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">set_shm</span><span class="params">(<span class="type">key_t</span> shm_key, <span class="type">int</span> shm_num, <span class="type">int</span> shm_flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_msq</span><span class="params">(<span class="type">key_t</span> msq_key, <span class="type">int</span> msq_flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_sem</span><span class="params">(<span class="type">key_t</span> sem_key, <span class="type">int</span> sem_val, <span class="type">int</span> sem_flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span> <span class="params">(<span class="type">int</span> sem_id)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span> <span class="params">(<span class="type">int</span> sem_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_flg;</span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> s_account_key;</span><br><span class="line"><span class="type">int</span> s_account_val;</span><br><span class="line"><span class="type">int</span> s_account_sem;</span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> s_customer_key;</span><br><span class="line"><span class="type">int</span> s_customer_val;</span><br><span class="line"><span class="type">int</span> s_customer_sem;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q_flg;</span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> q_sofa_key;</span><br><span class="line"><span class="type">int</span> q_sofa_id;</span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> q_wait_key;</span><br><span class="line"><span class="type">int</span> q_wait_id;</span><br></pre></td></tr></table></figure>

<p>cu.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* get_ipc_id() 从/proc/sysvipc/⽂件系统中获取 IPC 的 id 号</span></span><br><span class="line"><span class="comment">* pfile: 对应/proc/sysvipc/⽬录中的 IPC ⽂件分别为</span></span><br><span class="line"><span class="comment">* msg-消息队列,sem-信号量,shm-共享内存</span></span><br><span class="line"><span class="comment">* key: 对应要获取的 IPC 的 id 号的键值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ipc_id</span><span class="params">(<span class="type">char</span> *proc_file, <span class="type">key_t</span> key)</span> </span>&#123;</span><br><span class="line"> FILE *pf; <span class="type">int</span> i, j;</span><br><span class="line"> <span class="type">char</span> line[BUFSZ], colum[BUFSZ];</span><br><span class="line"> <span class="keyword">if</span> ((pf = <span class="built_in">fopen</span>(proc_file, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;Proc file not open&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">fgets</span>(line, BUFSZ, pf);</span><br><span class="line"> <span class="keyword">while</span> (!<span class="built_in">feof</span>(pf)) &#123;</span><br><span class="line"> i = j = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">fgets</span>(line, BUFSZ, pf);</span><br><span class="line"> <span class="keyword">while</span> (line[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line"> <span class="keyword">while</span> (line[i] != <span class="string">&#x27; &#x27;</span>) colum[j++] = line[i++];</span><br><span class="line"> colum[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">atoi</span>(colum) != key) <span class="keyword">continue</span>;</span><br><span class="line"> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (line[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line"> <span class="keyword">while</span> (line[i] != <span class="string">&#x27; &#x27;</span>) colum[j++] = line[i++];</span><br><span class="line"> colum[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> i = <span class="built_in">atoi</span>(colum);</span><br><span class="line"> <span class="built_in">fclose</span>(pf);</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">fclose</span>(pf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 信号灯上的down/up 操作</span></span><br><span class="line"><span class="comment">* semid:信号灯数组标识符</span></span><br><span class="line"><span class="comment">* semnum:信号灯数组下标</span></span><br><span class="line"><span class="comment">* buf:操作信号灯的结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> sem_id)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sembuf</span> buf;</span><br><span class="line"> buf.sem_op = <span class="number">-1</span>;</span><br><span class="line"> buf.sem_num = <span class="number">0</span>;</span><br><span class="line"> buf.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> ((<span class="built_in">semop</span>(sem_id, &amp;buf, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;down error &quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> sem_id)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sembuf</span> buf;</span><br><span class="line"> buf.sem_op = <span class="number">1</span>;</span><br><span class="line"> buf.sem_num = <span class="number">0</span>;</span><br><span class="line"> buf.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> ((<span class="built_in">semop</span>(sem_id, &amp;buf, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;up error &quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* set_sem 函数建⽴⼀个具有 n 个信号灯的信号量</span></span><br><span class="line"><span class="comment">* 如果建⽴成功，返回 ⼀个信号灯数组的标识符 sem_id</span></span><br><span class="line"><span class="comment">* 输⼊参数：</span></span><br><span class="line"><span class="comment">* sem_key 信号灯数组的键值</span></span><br><span class="line"><span class="comment">* sem_val 信号灯数组中信号灯的个数</span></span><br><span class="line"><span class="comment">* sem_flag 信号等数组的存取权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_sem</span><span class="params">(<span class="type">key_t</span> sem_key, <span class="type">int</span> sem_val, <span class="type">int</span> sem_flg)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> sem_id;</span><br><span class="line"> Sem_uns sem_arg;</span><br><span class="line"> <span class="comment">//测试由 sem_key 标识的信号灯数组是否已经建⽴</span></span><br><span class="line"> <span class="keyword">if</span> ((sem_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/sem&quot;</span>, sem_key)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line"> <span class="comment">//semget 新建⼀个信号灯,其标号返回到 sem_id</span></span><br><span class="line"> <span class="keyword">if</span> ((sem_id = <span class="built_in">semget</span>(sem_key, <span class="number">1</span>, sem_flg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;semaphore create error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//设置信号灯的初值</span></span><br><span class="line"> sem_arg.val = sem_val;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;semaphore set error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sem_id; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* set_shm 函数建⽴⼀个具有 n 个字节 的共享内存区</span></span><br><span class="line"><span class="comment">* 如果建⽴成功，返回 ⼀个指向该内存区⾸地址的指针 shm_buf</span></span><br><span class="line"><span class="comment">* 输⼊参数：</span></span><br><span class="line"><span class="comment">* shm_key 共享内存的键值</span></span><br><span class="line"><span class="comment">* shm_val 共享内存字节的⻓度</span></span><br><span class="line"><span class="comment">* shm_flag 共享内存的存取权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">set_shm</span><span class="params">(<span class="type">key_t</span> shm_key, <span class="type">int</span> shm_num, <span class="type">int</span> shm_flg)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> i, shm_id;</span><br><span class="line"> <span class="type">char</span> *shm_buf;</span><br><span class="line"> <span class="comment">//测试由 shm_key 标识的共享内存区是否已经建⽴</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/shm&quot;</span>, shm_key)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line"> <span class="comment">//shmget 新建 ⼀个⻓度为 shm_num 字节的共享内存,其标号返回shm_id</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_id = <span class="built_in">shmget</span>(shm_key, shm_num, shm_flg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;shareMemory set error&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//shmat 将由 shm_id 标识的共享内存附加给指针 shm_buf</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_buf = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shm_id, <span class="number">0</span>, <span class="number">0</span>)) &lt; (<span class="type">char</span> *)<span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;get shareMemory error&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shm_num; i++) shm_buf[i] = <span class="number">0</span>; <span class="comment">//初始为 0</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//shm_key 标识的共享内存区已经建⽴,将由 shm_id 标识的共享内存附加给指针 shm_buf</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_buf = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shm_id, <span class="number">0</span>, <span class="number">0</span>)) &lt; (<span class="type">char</span> *)<span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;get shareMemory error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> shm_buf; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* set_msq 函数建⽴⼀个消息队列</span></span><br><span class="line"><span class="comment">* 如果建⽴成功，返回 ⼀个消息队列的标识符 msq_id</span></span><br><span class="line"><span class="comment">* 输⼊参数：</span></span><br><span class="line"><span class="comment">* msq_key 消息队列的键值</span></span><br><span class="line"><span class="comment">* msq_flag 消息队列的存取权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_msq</span><span class="params">(<span class="type">key_t</span> msq_key, <span class="type">int</span> msq_flg)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> msq_id;</span><br><span class="line"> <span class="comment">//测试由 msq_key 标识的消息队列是否已经建⽴</span></span><br><span class="line"> <span class="keyword">if</span> ((msq_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/msg&quot;</span>, msq_key)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line"> <span class="comment">//msgget 新建⼀个消息队列,其标号返回到 msq_id</span></span><br><span class="line"> <span class="keyword">if</span> ((msq_id = <span class="built_in">msgget</span>(msq_key, msq_flg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;messageQueue set error&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> msq_id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    Msg_buf msg_arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msqid_ds</span> msg_sofa;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msqid_ds</span> msg_wait;</span><br><span class="line"><span class="comment">//建立沙发消息队列</span></span><br><span class="line">    q_flg=IPC_CREAT | <span class="number">0644</span>;</span><br><span class="line">    q_sofa_key=<span class="number">100</span>;</span><br><span class="line">    q_sofa_id=<span class="built_in">set_msq</span>(q_sofa_key,q_flg);</span><br><span class="line"><span class="comment">//建立等候室消息队列</span></span><br><span class="line">    q_wait_key=<span class="number">200</span>;</span><br><span class="line">    q_wait_id=<span class="built_in">set_msq</span>(q_wait_key,q_flg);</span><br><span class="line"><span class="comment">//建立一个同步顾客信号量</span></span><br><span class="line">    sem_flg=IPC_CREAT | <span class="number">0644</span>;</span><br><span class="line">    s_customer_key=<span class="number">300</span>;</span><br><span class="line">    s_customer_val=<span class="number">0</span>;</span><br><span class="line">    s_customer_sem=<span class="built_in">set_sem</span>(s_customer_key,s_customer_val,sem_flg);</span><br><span class="line"><span class="comment">//建立一个互斥帐本信号量</span></span><br><span class="line">    s_account_key=<span class="number">400</span>;</span><br><span class="line">    s_account_val=<span class="number">1</span>;</span><br><span class="line">    s_account_sem=<span class="built_in">set_sem</span>(s_account_key,s_account_val,sem_flg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立 3 个理发师进程</span></span><br><span class="line">    <span class="type">int</span> pid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid[i]=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">msgctl</span>(q_sofa_id,IPC_STAT,&amp;msg_sofa);</span><br><span class="line">                <span class="keyword">if</span>(msg_sofa.msg_qnum==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d 号理发师睡眠\n&quot;</span>,<span class="built_in">getpid</span>()); </span><br><span class="line">                <span class="comment">//以阻塞方式从沙发队列接收一条消息</span></span><br><span class="line">                <span class="built_in">msgrcv</span>(q_sofa_id,&amp;msg_arg,<span class="built_in">sizeof</span>(msg_arg),SOFA,<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//唤醒顾客进程,让下一顾客坐入沙发</span></span><br><span class="line">                <span class="built_in">up</span>(s_customer_sem);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 号理发师给 %d 号顾客理发\n&quot;</span>,<span class="built_in">getpid</span>(),msg_arg.mid);</span><br><span class="line">                <span class="comment">//用进程休眠一个随机时间模拟理发过程。</span></span><br><span class="line">                <span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">4</span>+<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//若有理发师正在收钱，则阻塞</span></span><br><span class="line">                <span class="built_in">down</span>(s_account_sem);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 号理发师向 %d 号顾客收费\n&quot;</span>,<span class="built_in">getpid</span>(),msg_arg.mid);</span><br><span class="line">                <span class="built_in">up</span>(s_account_sem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ipc.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* get_ipc_id() 从/proc/sysvipc/⽂件系统中获取 IPC 的 id 号</span></span><br><span class="line"><span class="comment">* pfile: 对应/proc/sysvipc/⽬录中的 IPC ⽂件分别为</span></span><br><span class="line"><span class="comment">* msg-消息队列,sem-信号量,shm-共享内存</span></span><br><span class="line"><span class="comment">* key: 对应要获取的 IPC 的 id 号的键值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_ipc_id</span><span class="params">(<span class="type">char</span> *proc_file, <span class="type">key_t</span> key)</span> </span>&#123;</span><br><span class="line"> FILE *pf; <span class="type">int</span> i, j;</span><br><span class="line"> <span class="type">char</span> line[BUFSZ], colum[BUFSZ];</span><br><span class="line"> <span class="keyword">if</span> ((pf = <span class="built_in">fopen</span>(proc_file, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;Proc file not open&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">fgets</span>(line, BUFSZ, pf);</span><br><span class="line"> <span class="keyword">while</span> (!<span class="built_in">feof</span>(pf)) &#123;</span><br><span class="line"> i = j = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">fgets</span>(line, BUFSZ, pf);</span><br><span class="line"> <span class="keyword">while</span> (line[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line"> <span class="keyword">while</span> (line[i] != <span class="string">&#x27; &#x27;</span>) colum[j++] = line[i++];</span><br><span class="line"> colum[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">atoi</span>(colum) != key) <span class="keyword">continue</span>;</span><br><span class="line"> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (line[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line"> <span class="keyword">while</span> (line[i] != <span class="string">&#x27; &#x27;</span>) colum[j++] = line[i++];</span><br><span class="line"> colum[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> i = <span class="built_in">atoi</span>(colum);</span><br><span class="line"> <span class="built_in">fclose</span>(pf);</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">fclose</span>(pf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 信号灯上的down/up 操作</span></span><br><span class="line"><span class="comment">* semid:信号灯数组标识符</span></span><br><span class="line"><span class="comment">* semnum:信号灯数组下标</span></span><br><span class="line"><span class="comment">* buf:操作信号灯的结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> sem_id)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sembuf</span> buf;</span><br><span class="line"> buf.sem_op = <span class="number">-1</span>;</span><br><span class="line"> buf.sem_num = <span class="number">0</span>;</span><br><span class="line"> buf.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> ((<span class="built_in">semop</span>(sem_id, &amp;buf, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;down error &quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> sem_id)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sembuf</span> buf;</span><br><span class="line"> buf.sem_op = <span class="number">1</span>;</span><br><span class="line"> buf.sem_num = <span class="number">0</span>;</span><br><span class="line"> buf.sem_flg = SEM_UNDO;</span><br><span class="line"> <span class="keyword">if</span> ((<span class="built_in">semop</span>(sem_id, &amp;buf, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;up error &quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* set_sem 函数建⽴⼀个具有 n 个信号灯的信号量</span></span><br><span class="line"><span class="comment">* 如果建⽴成功，返回 ⼀个信号灯数组的标识符 sem_id</span></span><br><span class="line"><span class="comment">* 输⼊参数：</span></span><br><span class="line"><span class="comment">* sem_key 信号灯数组的键值</span></span><br><span class="line"><span class="comment">* sem_val 信号灯数组中信号灯的个数</span></span><br><span class="line"><span class="comment">* sem_flag 信号等数组的存取权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_sem</span><span class="params">(<span class="type">key_t</span> sem_key, <span class="type">int</span> sem_val, <span class="type">int</span> sem_flg)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> sem_id;</span><br><span class="line"> Sem_uns sem_arg;</span><br><span class="line"> <span class="comment">//测试由 sem_key 标识的信号灯数组是否已经建⽴</span></span><br><span class="line"> <span class="keyword">if</span> ((sem_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/sem&quot;</span>, sem_key)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line"> <span class="comment">//semget 新建⼀个信号灯,其标号返回到 sem_id</span></span><br><span class="line"> <span class="keyword">if</span> ((sem_id = <span class="built_in">semget</span>(sem_key, <span class="number">1</span>, sem_flg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;semaphore create error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//设置信号灯的初值</span></span><br><span class="line"> sem_arg.val = sem_val;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;semaphore set error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sem_id; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* set_shm 函数建⽴⼀个具有 n 个字节 的共享内存区</span></span><br><span class="line"><span class="comment">* 如果建⽴成功，返回 ⼀个指向该内存区⾸地址的指针 shm_buf</span></span><br><span class="line"><span class="comment">* 输⼊参数：</span></span><br><span class="line"><span class="comment">* shm_key 共享内存的键值</span></span><br><span class="line"><span class="comment">* shm_val 共享内存字节的⻓度</span></span><br><span class="line"><span class="comment">* shm_flag 共享内存的存取权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">set_shm</span><span class="params">(<span class="type">key_t</span> shm_key, <span class="type">int</span> shm_num, <span class="type">int</span> shm_flg)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> i, shm_id;</span><br><span class="line"> <span class="type">char</span> *shm_buf;</span><br><span class="line"> <span class="comment">//测试由 shm_key 标识的共享内存区是否已经建⽴</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/shm&quot;</span>, shm_key)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line"> <span class="comment">//shmget 新建 ⼀个⻓度为 shm_num 字节的共享内存,其标号返回shm_id</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_id = <span class="built_in">shmget</span>(shm_key, shm_num, shm_flg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;shareMemory set error&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//shmat 将由 shm_id 标识的共享内存附加给指针 shm_buf</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_buf = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shm_id, <span class="number">0</span>, <span class="number">0</span>)) &lt; (<span class="type">char</span> *)<span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;get shareMemory error&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shm_num; i++) shm_buf[i] = <span class="number">0</span>; <span class="comment">//初始为 0</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//shm_key 标识的共享内存区已经建⽴,将由 shm_id 标识的共享内存附加给指针 shm_buf</span></span><br><span class="line"> <span class="keyword">if</span> ((shm_buf = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shm_id, <span class="number">0</span>, <span class="number">0</span>)) &lt; (<span class="type">char</span> *)<span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;get shareMemory error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> shm_buf; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* set_msq 函数建⽴⼀个消息队列</span></span><br><span class="line"><span class="comment">* 如果建⽴成功，返回 ⼀个消息队列的标识符 msq_id</span></span><br><span class="line"><span class="comment">* 输⼊参数：</span></span><br><span class="line"><span class="comment">* msq_key 消息队列的键值</span></span><br><span class="line"><span class="comment">* msq_flag 消息队列的存取权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_msq</span><span class="params">(<span class="type">key_t</span> msq_key, <span class="type">int</span> msq_flg)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> msq_id;</span><br><span class="line"> <span class="comment">//测试由 msq_key 标识的消息队列是否已经建⽴</span></span><br><span class="line"> <span class="keyword">if</span> ((msq_id = <span class="built_in">get_ipc_id</span>(<span class="string">&quot;/proc/sysvipc/msg&quot;</span>, msq_key)) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line"> <span class="comment">//msgget 新建⼀个消息队列,其标号返回到 msq_id</span></span><br><span class="line"> <span class="keyword">if</span> ((msq_id = <span class="built_in">msgget</span>(msq_key, msq_flg)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">perror</span>(<span class="string">&quot;messageQueue set error&quot;</span>); <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> msq_id; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    Msg_buf msg_arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msqid_ds</span> msg_sofa;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msqid_ds</span> msg_wait;</span><br><span class="line"><span class="comment">//建立沙发消息队列</span></span><br><span class="line">    q_flg=IPC_CREAT | <span class="number">0644</span>;</span><br><span class="line">    q_sofa_key=<span class="number">100</span>;</span><br><span class="line">    q_sofa_id=<span class="built_in">set_msq</span>(q_sofa_key,q_flg);</span><br><span class="line"><span class="comment">//建立等候室消息队列</span></span><br><span class="line">    q_wait_key=<span class="number">200</span>;</span><br><span class="line">    q_wait_id=<span class="built_in">set_msq</span>(q_wait_key,q_flg);</span><br><span class="line"><span class="comment">//建立一个同步顾客信号量</span></span><br><span class="line">    sem_flg=IPC_CREAT | <span class="number">0644</span>;</span><br><span class="line">    s_customer_key=<span class="number">300</span>;</span><br><span class="line">    s_customer_val=<span class="number">0</span>;</span><br><span class="line">    s_customer_sem=<span class="built_in">set_sem</span>(s_customer_key,s_customer_val,sem_flg);</span><br><span class="line"><span class="comment">//建立一个互斥帐本信号量</span></span><br><span class="line">    s_account_key=<span class="number">400</span>;</span><br><span class="line">    s_account_val=<span class="number">1</span>;</span><br><span class="line">    s_account_sem=<span class="built_in">set_sem</span>(s_account_key,s_account_val,sem_flg);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> customernum=<span class="number">1</span>;<span class="comment">//顾客序号</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//IPC_STAT 为⾮破坏性读，从队列中读出⼀个 msgid_ds 结构填充缓冲 buf</span></span><br><span class="line">        <span class="built_in">msgctl</span>(q_sofa_id,IPC_STAT,&amp;msg_sofa);</span><br><span class="line">        <span class="keyword">if</span>(msg_sofa.msg_qnum&lt;<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            quest_flg=IPC_NOWAIT;<span class="comment">//以非阻塞方式接收消息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">msgrcv</span>(q_wait_id,&amp;msg_arg,<span class="built_in">sizeof</span>(msg_arg),WAIT,quest_flg)&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                msg_arg.mtype=SOFA;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 号新顾客坐入沙发\n&quot;</span>,msg_arg.mid);</span><br><span class="line">                <span class="built_in">msgsnd</span>(q_sofa_id,&amp;msg_arg,<span class="built_in">sizeof</span>(msg_arg),IPC_NOWAIT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                msg_arg.mtype=SOFA;</span><br><span class="line">                msg_arg.mid=customernum;</span><br><span class="line">                customernum++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d 号新顾客坐入沙发\n&quot;</span>,msg_arg.mid);</span><br><span class="line">                <span class="built_in">msgsnd</span>(q_sofa_id,&amp;msg_arg,<span class="built_in">sizeof</span>(msg_arg),IPC_NOWAIT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">msgctl</span>(q_wait_id,IPC_STAT,&amp;msg_wait);</span><br><span class="line">            <span class="keyword">if</span>(msg_wait.msg_qnum&lt;<span class="number">13</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                msg_arg.mtype=WAIT;</span><br><span class="line">                msg_arg.mid=customernum;</span><br><span class="line">                customernum++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;沙发座满,%d 号新顾客进入等候室\n&quot;</span>,msg_arg.mid);</span><br><span class="line">                <span class="built_in">msgsnd</span>(q_wait_id,&amp;msg_arg,<span class="built_in">sizeof</span>(msg_arg),IPC_NOWAIT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;等候室满,%d 号新顾客没有进入理发店\n&quot;</span>,customernum);</span><br><span class="line">                <span class="built_in">down</span>(s_customer_sem);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用进程休眠一个随机时间模拟顾客到达的时间间隔</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">5</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结论分析-4"><a href="#结论分析-4" class="headerlink" title="结论分析"></a>结论分析</h3><p>这个实验让我进一步研究和实践了操作系统中关于并发进程同步与互斥操作的一些经典问题的解法，加深了我对于非对称性互斥问题相关概念的理解。在实验中，我观察和体验了非对称性互斥问题的并发控制方法，进一步了解了Linux系统中IPC进程同步工具的用法，并训练了解决对该类问题的实际编程、调试和分析问题的能力。</p>
<p> 在实验中，我发现非对称性互斥问题是一个常见的问题，涉及多个进程共同访问共享资源的情况下，需要进行有效的同步和互斥控制，以确保数据的正确性和完整性。为了解决这个问题，我们学习了一些经典的解决方案，如信号量、互斥锁和条件变量等，并在实验中应用了这些方案。</p>
<p> 通过实验，我深刻地理解了这些控制方法的原理和实现细节，学会了使用Linux系统中的IPC工具，如semaphore、mutex和condition variable等来实现同步和互斥操作。此外，我还学会了如何编写、调试和分析多线程程序，以解决由并发控制引起的各种问题。</p>
<h2 id="实验七-内存页面置换算法实验"><a href="#实验七-内存页面置换算法实验" class="headerlink" title="实验七 内存页面置换算法实验"></a>实验七 内存页面置换算法实验</h2><h3 id="实验目的-5"><a href="#实验目的-5" class="headerlink" title="实验目的"></a>实验目的</h3><p>加深对于存储管理的了解，掌握虚拟存储器的实现原理;观察和了解重要的页面置换算法和置换过程。练习模拟算法的编程技巧，锻炼分析试验数据的能力。</p>
<h3 id="实验说明-5"><a href="#实验说明-5" class="headerlink" title="实验说明"></a>实验说明</h3><p>1.示例实验程序中模拟两种置换算法:LRU算法和FIFO算法<br>2.能对两种算法给定任意序列不同的页面引用串和任意帧实内存块数的组合测试，显示页置换的过程。<br>3．能统计和报告不同置换算法情况下依次淘汰的页号、缺页次数（页错误数)<br>和缺页率。比较两种置换算法在给定条件下的优劣。<br>4.为了能方便的扩充页面置换算法，更好的描述置换过程，示例实验程序采用<br>了C++语言用Replace类描述了置换算法及其属性。</p>
<h3 id="独立实验-5"><a href="#独立实验-5" class="headerlink" title="独立实验"></a>独立实验</h3><p>请在以上示例实验程序中补充“增强二次机会”等置换算法的模拟程序。输入不同的内存页面引用串和实存帧数，观察并分析其页面置换效果和性能，并将其与LRU和 FIFO算法进行比较。改进以上示例实验程序，使之能够随机的产生内存页面引用串，以便能动态的观测各种置换算法的性能。</p>
<p>vmrp.c Code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmrp.h&quot;</span></span></span><br><span class="line">Replace::<span class="built_in">Replace</span>()&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//设定总得访问页数,并分配相应的引用页号和淘汰页号记录数组空间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input page numbers :&quot;</span> ;</span><br><span class="line">    cin &gt;&gt; PageNumber;</span><br><span class="line">    ReferencePage = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">sizeof</span>(<span class="type">int</span>) * PageNumber];</span><br><span class="line">    EliminatePage = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">sizeof</span>(<span class="type">int</span>) * PageNumber];</span><br><span class="line">    <span class="comment">//输入引用页号序列(页面走向),初始化引用页数组</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input reference page string :&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PageNumber; i++)</span><br><span class="line">    cin &gt;&gt; ReferencePage[i];<span class="comment">//引用页暂存引用数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设定内存实页数(帧数),并分配相应的实页号记录数组空间(页号栈)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please input page frames :&quot;</span>;</span><br><span class="line">    cin &gt;&gt; FrameNumber;</span><br><span class="line">    PageFrames = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">sizeof</span>(<span class="type">int</span>) * FrameNumber];</span><br><span class="line">    Referencebit=<span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">sizeof</span>(<span class="type">int</span>) * FrameNumber];</span><br><span class="line">    count=<span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">sizeof</span>(<span class="type">int</span>) * FrameNumber];</span><br><span class="line">    Modifybit=<span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">sizeof</span>(<span class="type">int</span>) * FrameNumber];</span><br><span class="line">&#125;</span><br><span class="line">Replace::~<span class="built_in">Replace</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::InitSpace</span><span class="params">(<span class="type">char</span> * MethodName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; MethodName &lt;&lt; endl;</span><br><span class="line">    FaultNumber=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//引用还未开始,-1 表示无引用页</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PageNumber; i++)</span><br><span class="line">    EliminatePage[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; FrameNumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PageFrames[i] = <span class="number">-1</span>;</span><br><span class="line">        Referencebit[i]=<span class="number">0</span>;</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">        Modifybit[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析统计选择的算法对于当前输入的页面走向的性能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Report</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//报告淘汰页顺序</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Eliminate page:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; EliminatePage[i]!=<span class="number">-1</span>; i++) cout &lt;&lt; EliminatePage[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//报告缺页数和缺页率</span></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Number of page faults = &quot;</span> &lt;&lt; FaultNumber &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Rate of page faults = &quot;</span> &lt;&lt; <span class="number">100</span>*(<span class="type">float</span>)FaultNumber/(<span class="type">float</span>)PageNumber &lt;&lt;</span><br><span class="line">    <span class="string">&quot;%&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最近最旧未用置换算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Lru</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,l,next;</span><br><span class="line">    <span class="built_in">InitSpace</span>(<span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">    <span class="comment">//循环装入引用页</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,l=<span class="number">0</span>; k &lt; PageNumber; k++)&#123;</span><br><span class="line">        next=ReferencePage[k];</span><br><span class="line">        <span class="comment">//检测引用页当前是否已在实存</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FrameNumber; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next == PageFrames[i])&#123;</span><br><span class="line">            <span class="comment">//引用页已在实存将其调整到页记录栈顶</span></span><br><span class="line">                next= PageFrames[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--) PageFrames[j] = PageFrames[j<span class="number">-1</span>];</span><br><span class="line">                PageFrames[<span class="number">0</span>]=next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(PageFrames[<span class="number">0</span>] == next)&#123;</span><br><span class="line">            <span class="comment">//如果引用页已放栈顶,则为不缺页,报告当前内存页号</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;FrameNumber; j++)</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[j]&gt;=<span class="number">0</span>) cout &lt;&lt; PageFrames[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//继续装入下一页</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果引用页还未放栈顶,则为缺页,缺页数加 1</span></span><br><span class="line">        FaultNumber++;</span><br><span class="line">        <span class="comment">//栈底页号记入淘汰页数组中</span></span><br><span class="line">        EliminatePage[l] = PageFrames[FrameNumber<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//向下压栈</span></span><br><span class="line">        <span class="keyword">for</span>(j=FrameNumber<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--) PageFrames[j]= PageFrames[j<span class="number">-1</span>];</span><br><span class="line">        PageFrames[<span class="number">0</span>]=next; <span class="comment">//引用页放栈顶</span></span><br><span class="line">        <span class="comment">//报告当前实存中页号</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;FrameNumber; j++)</span><br><span class="line">        <span class="keyword">if</span>(PageFrames[j]&gt;=<span class="number">0</span>) cout &lt;&lt; PageFrames[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">//报告当前淘汰的页号</span></span><br><span class="line">        <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; EliminatePage[l++] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分析统计选择的算法对于当前引用的页面走向的性能</span></span><br><span class="line"><span class="built_in">Report</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先进先出置换算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Fifo</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,l,next;</span><br><span class="line">    <span class="built_in">InitSpace</span>(<span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line">    <span class="comment">//循环装入引用页</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,j=l=<span class="number">0</span>; k &lt; PageNumber; k++)&#123;</span><br><span class="line">        next=ReferencePage[k];</span><br><span class="line">        <span class="comment">//如果引用页已在实存中,报告实存页号</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;FrameNumber; i++) </span><br><span class="line">            <span class="keyword">if</span>(next==PageFrames[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;FrameNumber)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FrameNumber; i++) </span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; PageFrames[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续引用下一页</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//引用页不在实存中,缺页数加 1</span></span><br><span class="line">        FaultNumber++;</span><br><span class="line">        EliminatePage[l]= PageFrames[j]; <span class="comment">//最先入页号记入淘汰页数组</span></span><br><span class="line">        PageFrames[j]=next; <span class="comment">//引用页号放最先入页号处</span></span><br><span class="line">        j = (j+<span class="number">1</span>)%FrameNumber; <span class="comment">//最先入页号循环下移</span></span><br><span class="line">        <span class="comment">//报告当前实存页号和淘汰页号</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FrameNumber; i++)</span><br><span class="line">            <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>) cout &lt;&lt; PageFrames[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; EliminatePage[l++] &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分析统计选择的算法对于当前引用的页面走向的性能</span></span><br><span class="line">    <span class="built_in">Report</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未实现的其他页置换算法入口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Clock</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j,i,k,l,next;</span><br><span class="line">    <span class="built_in">InitSpace</span>(<span class="string">&quot;Clock&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,j=l=<span class="number">0</span>;k&lt;PageNumber;k++)&#123;</span><br><span class="line">        next=ReferencePage[k];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next==PageFrames[i])&#123;</span><br><span class="line">                Referencebit[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;FrameNumber)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Referencebit[j]==<span class="number">1</span>)&#123;</span><br><span class="line">            Referencebit[j]=<span class="number">0</span>;<span class="comment">//reset</span></span><br><span class="line">            j=(j+<span class="number">1</span>)%FrameNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        EliminatePage[l]=PageFrames[j];<span class="comment">//最先入页号记入淘汰页数组</span></span><br><span class="line">        PageFrames[j]=next;</span><br><span class="line">        Referencebit[j]=<span class="number">1</span>;</span><br><span class="line">        FaultNumber++;</span><br><span class="line">        j=(j+<span class="number">1</span>)%FrameNumber;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>) </span><br><span class="line">                cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;EliminatePage[l++]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Report</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Eclock</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j,i,k,l,next;</span><br><span class="line">    <span class="built_in">InitSpace</span>(<span class="string">&quot;Eclock&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,j=l=<span class="number">0</span>;k&lt;PageNumber;k++)&#123;</span><br><span class="line">        next=ReferencePage[k];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;frn:&quot;&lt;&lt;FrameNumber&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next==PageNumber)&#123;</span><br><span class="line">                Referencebit[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;FrameNumber)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(Referencebit[j]!=<span class="number">0</span>||Modifybit[j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            j=(j+<span class="number">1</span>)%FrameNumber;</span><br><span class="line">            tmp++;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;=FrameNumber)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;FrameNumber)&#123;</span><br><span class="line">            EliminatePage[l]=PageFrames[j];<span class="comment">//最先入页号记入淘汰页数组</span></span><br><span class="line">            PageFrames[j]=next;</span><br><span class="line">            Referencebit[j]=<span class="number">1</span>;</span><br><span class="line">            Modifybit[j]=<span class="number">1</span>;</span><br><span class="line">            FaultNumber++;</span><br><span class="line">            j=(j+<span class="number">1</span>)%FrameNumber;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>) </span><br><span class="line">                    cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;EliminatePage[l++]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!(Referencebit==<span class="number">0</span>&amp;&amp;Modifybit[j]==<span class="number">1</span>))&#123;</span><br><span class="line">                Referencebit[j]=<span class="number">0</span>;</span><br><span class="line">                j=(j+<span class="number">1</span>)%FrameNumber;</span><br><span class="line">                tmp++;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;=FrameNumber)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            EliminatePage[l]=PageFrames[j];<span class="comment">//最先入页号记入淘汰页数组</span></span><br><span class="line">            PageFrames[j]=next;</span><br><span class="line">            Referencebit[j]=<span class="number">1</span>;</span><br><span class="line">            Modifybit[j]=<span class="number">1</span>;</span><br><span class="line">            FaultNumber++;</span><br><span class="line">            j=(j+<span class="number">1</span>)%FrameNumber;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>) </span><br><span class="line">                    cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;EliminatePage[l++]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Report</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Lfu</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j,i,k,l,next;</span><br><span class="line">    <span class="built_in">InitSpace</span>(<span class="string">&quot;Lfu&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,j=l=<span class="number">0</span>;k&lt;PageNumber;k++)&#123;</span><br><span class="line">        next=ReferencePage[k];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next==PageFrames[i])&#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;FrameNumber)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FaultNumber++;</span><br><span class="line">        <span class="type">int</span> min=count[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ind=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=count[i];</span><br><span class="line">                ind=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        EliminatePage[l]=PageFrames[ind];</span><br><span class="line">        PageFrames[ind]=next;</span><br><span class="line">        count[ind]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;EliminatePage[l++]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Report</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace::Mfu</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j,i,k,l,next;</span><br><span class="line">    <span class="built_in">InitSpace</span>(<span class="string">&quot;mfu&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;FrameNumber;x++)&#123;</span><br><span class="line">        count[x]=<span class="number">1e8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,j=l=<span class="number">0</span>;k&lt;PageNumber;k++)&#123;</span><br><span class="line">        next=ReferencePage[k];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;frn:&quot;&lt;&lt;FrameNumber&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next==PageFrames[i])&#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;FrameNumber)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)</span><br><span class="line">                <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                    cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FaultNumber++;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1e7</span>;</span><br><span class="line">        <span class="type">int</span> ind=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max=count[i];</span><br><span class="line">                ind=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        EliminatePage[l]=PageFrames[ind];</span><br><span class="line">        PageFrames[ind]=next;</span><br><span class="line">        count[ind]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;FrameNumber;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(PageFrames[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                cout&lt;&lt;PageFrames[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(EliminatePage[l]&gt;=<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;EliminatePage[l++]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Report</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    Replace * vmpr = <span class="keyword">new</span> <span class="built_in">Replace</span>();</span><br><span class="line">    vmpr-&gt;<span class="built_in">Lru</span>();<span class="comment">//vmpr-&gt;vampire</span></span><br><span class="line">    vmpr-&gt;<span class="built_in">Fifo</span>();</span><br><span class="line">    vmpr-&gt;<span class="built_in">Clock</span>();</span><br><span class="line">    vmpr-&gt;<span class="built_in">Eclock</span>();</span><br><span class="line">    vmpr-&gt;<span class="built_in">Lfu</span>();</span><br><span class="line">    vmpr-&gt;<span class="built_in">Mfu</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vmrp.h Code </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Replace</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Replace</span>();</span><br><span class="line">        ~<span class="built_in">Replace</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InitSpace</span><span class="params">(<span class="type">char</span> * MethodName)</span></span>; <span class="comment">//初始化页号记录</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Report</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// 报告算法执行情况</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Fifo</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//先进先出算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Lru</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//最近最旧未用算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Clock</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//时钟(二次机会)置换算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Eclock</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//增强二次机会置换算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Lfu</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//最不经常使用置换算法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Mfu</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//最经常使用置换算法</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> * ReferencePage ; <span class="comment">//存放要访问到的页号</span></span><br><span class="line">        <span class="type">int</span> * EliminatePage ; <span class="comment">//存放淘汰页号</span></span><br><span class="line">        <span class="type">int</span> * PageFrames ;</span><br><span class="line">        <span class="comment">//存放当前正在实存中的页号</span></span><br><span class="line">        <span class="type">int</span> PageNumber;</span><br><span class="line">        <span class="comment">//访问页数</span></span><br><span class="line">        <span class="type">int</span> FrameNumber;</span><br><span class="line">        <span class="comment">//实存帧数</span></span><br><span class="line">        <span class="type">int</span> FaultNumber;</span><br><span class="line">        <span class="comment">//失败页数</span></span><br><span class="line">        <span class="type">int</span> *Referencebit;</span><br><span class="line">        <span class="type">int</span> *count;</span><br><span class="line">        <span class="type">int</span> *Modifybit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结论分析-5"><a href="#结论分析-5" class="headerlink" title="结论分析"></a>结论分析</h3><p>在进行上述实验中，我们通过补充”增强二次机会”等置换算法的模拟程序，对不同的页面置换算法进行了比较和分析。同时，我们还改进了示例实验程序，使其能够随机产生内存页面引用串，以便动态观测各种置换算法的性能。以下是我的实验心得和总结：</p>
<p>首先，通过实验我们深入了解了不同页面置换算法的工作原理和性能特点。在增强二次机会算法中，我们考虑了页面的访问情况和修改位，根据这些信息来决定页面的替换。相比于LRU（最近最少使用）算法和FIFO（先进先出）算法，增强二次机会算法能够更好地综合考虑页面的使用频率和修改情况，从而提高了页面置换的准确性和效率。</p>
<p>其次，我们观察和分析了不同置换算法在不同内存页面引用串和实存帧数下的性能表现。通过随机生成内存页面引用串，我们能够模拟更加真实的应用场景，并观察算法在不同负载条件下的表现。我们可以通过性能指标如缺页率（Page Fault Rate）来评估不同算法的性能。实验结果显示，增强二次机会算法在大多数情况下都能够获得较低的缺页率，相比之下，LRU和FIFO算法的性能略逊一筹。这表明增强二次机会算法在综合考虑了页面使用频率和修改情况后，能够更好地适应不同负载条件，并提供更高效的页面置换策略。</p>
<p>最后，通过改进实验程序，我们能够灵活地模拟和比较不同置换算法的性能。随机生成内存页面引用串使我们能够观察到算法在不同负载下的表现，并且可以更好地了解算法对于不同应用场景的适应性。这对于系统设计者和开发人员来说是非常有价值的，因为他们可以根据应用的特点和负载条件来选择合适的页面置换算法，从而提高系统的性能和响应能力。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://jcvvv.github.io">锦尘</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jcvvv.github.io/2023/04/01/Operating%20system%20experiments/">https://jcvvv.github.io/2023/04/01/Operating%20system%20experiments/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jcvvv.github.io" target="_blank">锦尘</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/pic/cover/21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/03/Nginx%20config/"><img class="prev-cover" src="/pic/cover/22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx配置教程</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/30/Data%20visualization%20course%20design/"><img class="next-cover" src="/pic/cover/19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据可视化知识点</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">锦尘</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JCvvv" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/475586532?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="mailto:1747624698@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">实验一 进程控制实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.3.</span> <span class="toc-text">独立实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">结论分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">实验二 进程通信实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-1"><span class="toc-number">3.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E-1"><span class="toc-number">3.2.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E9%AA%8C-1"><span class="toc-number">3.3.</span> <span class="toc-text">独立实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%88%86%E6%9E%90-1"><span class="toc-number">3.4.</span> <span class="toc-text">结论分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.</span> <span class="toc-text">实验三 进程调度算法实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-2"><span class="toc-number">4.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E-2"><span class="toc-number">4.2.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E9%AA%8C-2"><span class="toc-number">4.3.</span> <span class="toc-text">独立实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%88%86%E6%9E%90-2"><span class="toc-number">4.4.</span> <span class="toc-text">结论分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AE%9E%E9%AA%8C"><span class="toc-number">5.</span> <span class="toc-text">实验四 进程同步实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-3"><span class="toc-number">5.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E-3"><span class="toc-number">5.2.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E9%AA%8C-3"><span class="toc-number">5.3.</span> <span class="toc-text">独立实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%88%86%E6%9E%90-3"><span class="toc-number">5.4.</span> <span class="toc-text">结论分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%AE%9E%E9%AA%8C"><span class="toc-number">6.</span> <span class="toc-text">实验五 进程互斥实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-4"><span class="toc-number">6.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E-4"><span class="toc-number">6.2.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E9%AA%8C-4"><span class="toc-number">6.3.</span> <span class="toc-text">独立实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%88%86%E6%9E%90-4"><span class="toc-number">6.4.</span> <span class="toc-text">结论分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%83-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text">实验七 内存页面置换算法实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-5"><span class="toc-number">7.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E-5"><span class="toc-number">7.2.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%AE%9E%E9%AA%8C-5"><span class="toc-number">7.3.</span> <span class="toc-text">独立实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E5%88%86%E6%9E%90-5"><span class="toc-number">7.4.</span> <span class="toc-text">结论分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/NoSqlExperiment/" title="NoSql实验报告">NoSql实验报告</a><time datetime="2023-11-19T16:00:00.000Z" title="发表于 2023-11-20 00:00:00">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/01/Internship%20report/" title="认知实习汇总">认知实习汇总</a><time datetime="2023-10-31T16:00:00.000Z" title="发表于 2023-11-01 00:00:00">2023-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/31/Software/" title="软件工程作业合集">软件工程作业合集</a><time datetime="2023-10-30T16:00:00.000Z" title="发表于 2023-10-31 00:00:00">2023-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/30/SMS/" title="SMS短信嗅探实验报告">SMS短信嗅探实验报告</a><time datetime="2023-10-29T16:00:00.000Z" title="发表于 2023-10-30 00:00:00">2023-10-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/20/Data%20Mining/" title="数据挖掘实验报告">数据挖掘实验报告</a><time datetime="2023-10-19T16:00:00.000Z" title="发表于 2023-10-20 00:00:00">2023-10-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/foot.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 锦尘</div><div class="footer_custom_text">欢迎你，不知道从哪来的朋友</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>